// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Management.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Management_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Management_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Management_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Management_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[27]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Management_2eproto;
namespace Global {
namespace Protocol {
namespace Server {
namespace Management {
class Account;
struct AccountDefaultTypeInternal;
extern AccountDefaultTypeInternal _Account_default_instance_;
class BlockedAccount;
struct BlockedAccountDefaultTypeInternal;
extern BlockedAccountDefaultTypeInternal _BlockedAccount_default_instance_;
class BlockedIPAddress;
struct BlockedIPAddressDefaultTypeInternal;
extern BlockedIPAddressDefaultTypeInternal _BlockedIPAddress_default_instance_;
class RequestAddAccount;
struct RequestAddAccountDefaultTypeInternal;
extern RequestAddAccountDefaultTypeInternal _RequestAddAccount_default_instance_;
class RequestAddBlockedAccount;
struct RequestAddBlockedAccountDefaultTypeInternal;
extern RequestAddBlockedAccountDefaultTypeInternal _RequestAddBlockedAccount_default_instance_;
class RequestAddBlockedIPAddress;
struct RequestAddBlockedIPAddressDefaultTypeInternal;
extern RequestAddBlockedIPAddressDefaultTypeInternal _RequestAddBlockedIPAddress_default_instance_;
class RequestChangeAccountPassword;
struct RequestChangeAccountPasswordDefaultTypeInternal;
extern RequestChangeAccountPasswordDefaultTypeInternal _RequestChangeAccountPassword_default_instance_;
class RequestDeleteAccount;
struct RequestDeleteAccountDefaultTypeInternal;
extern RequestDeleteAccountDefaultTypeInternal _RequestDeleteAccount_default_instance_;
class RequestDisableAccount;
struct RequestDisableAccountDefaultTypeInternal;
extern RequestDisableAccountDefaultTypeInternal _RequestDisableAccount_default_instance_;
class RequestEnableAccount;
struct RequestEnableAccountDefaultTypeInternal;
extern RequestEnableAccountDefaultTypeInternal _RequestEnableAccount_default_instance_;
class RequestListAccount;
struct RequestListAccountDefaultTypeInternal;
extern RequestListAccountDefaultTypeInternal _RequestListAccount_default_instance_;
class RequestListBlockedAccounts;
struct RequestListBlockedAccountsDefaultTypeInternal;
extern RequestListBlockedAccountsDefaultTypeInternal _RequestListBlockedAccounts_default_instance_;
class RequestListBlockedIPAddresses;
struct RequestListBlockedIPAddressesDefaultTypeInternal;
extern RequestListBlockedIPAddressesDefaultTypeInternal _RequestListBlockedIPAddresses_default_instance_;
class RequestRemoveBlockedAccount;
struct RequestRemoveBlockedAccountDefaultTypeInternal;
extern RequestRemoveBlockedAccountDefaultTypeInternal _RequestRemoveBlockedAccount_default_instance_;
class RequestRemoveBlockedIPAddress;
struct RequestRemoveBlockedIPAddressDefaultTypeInternal;
extern RequestRemoveBlockedIPAddressDefaultTypeInternal _RequestRemoveBlockedIPAddress_default_instance_;
class ResponseAddAccount;
struct ResponseAddAccountDefaultTypeInternal;
extern ResponseAddAccountDefaultTypeInternal _ResponseAddAccount_default_instance_;
class ResponseAddBlockedAccount;
struct ResponseAddBlockedAccountDefaultTypeInternal;
extern ResponseAddBlockedAccountDefaultTypeInternal _ResponseAddBlockedAccount_default_instance_;
class ResponseAddBlockedIPAddress;
struct ResponseAddBlockedIPAddressDefaultTypeInternal;
extern ResponseAddBlockedIPAddressDefaultTypeInternal _ResponseAddBlockedIPAddress_default_instance_;
class ResponseChangeAccountPassword;
struct ResponseChangeAccountPasswordDefaultTypeInternal;
extern ResponseChangeAccountPasswordDefaultTypeInternal _ResponseChangeAccountPassword_default_instance_;
class ResponseDeleteAccount;
struct ResponseDeleteAccountDefaultTypeInternal;
extern ResponseDeleteAccountDefaultTypeInternal _ResponseDeleteAccount_default_instance_;
class ResponseDisableAccount;
struct ResponseDisableAccountDefaultTypeInternal;
extern ResponseDisableAccountDefaultTypeInternal _ResponseDisableAccount_default_instance_;
class ResponseEnableAccount;
struct ResponseEnableAccountDefaultTypeInternal;
extern ResponseEnableAccountDefaultTypeInternal _ResponseEnableAccount_default_instance_;
class ResponseListAccount;
struct ResponseListAccountDefaultTypeInternal;
extern ResponseListAccountDefaultTypeInternal _ResponseListAccount_default_instance_;
class ResponseListBlockedAccounts;
struct ResponseListBlockedAccountsDefaultTypeInternal;
extern ResponseListBlockedAccountsDefaultTypeInternal _ResponseListBlockedAccounts_default_instance_;
class ResponseListBlockedIPAddresses;
struct ResponseListBlockedIPAddressesDefaultTypeInternal;
extern ResponseListBlockedIPAddressesDefaultTypeInternal _ResponseListBlockedIPAddresses_default_instance_;
class ResponseRemoveBlockedAccount;
struct ResponseRemoveBlockedAccountDefaultTypeInternal;
extern ResponseRemoveBlockedAccountDefaultTypeInternal _ResponseRemoveBlockedAccount_default_instance_;
class ResponseRemoveBlockedIPAddress;
struct ResponseRemoveBlockedIPAddressDefaultTypeInternal;
extern ResponseRemoveBlockedIPAddressDefaultTypeInternal _ResponseRemoveBlockedIPAddress_default_instance_;
}  // namespace Management
}  // namespace Server
}  // namespace Protocol
}  // namespace Global
PROTOBUF_NAMESPACE_OPEN
template<> ::Global::Protocol::Server::Management::Account* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::Account>(Arena*);
template<> ::Global::Protocol::Server::Management::BlockedAccount* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::BlockedAccount>(Arena*);
template<> ::Global::Protocol::Server::Management::BlockedIPAddress* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::BlockedIPAddress>(Arena*);
template<> ::Global::Protocol::Server::Management::RequestAddAccount* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::RequestAddAccount>(Arena*);
template<> ::Global::Protocol::Server::Management::RequestAddBlockedAccount* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::RequestAddBlockedAccount>(Arena*);
template<> ::Global::Protocol::Server::Management::RequestAddBlockedIPAddress* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::RequestAddBlockedIPAddress>(Arena*);
template<> ::Global::Protocol::Server::Management::RequestChangeAccountPassword* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::RequestChangeAccountPassword>(Arena*);
template<> ::Global::Protocol::Server::Management::RequestDeleteAccount* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::RequestDeleteAccount>(Arena*);
template<> ::Global::Protocol::Server::Management::RequestDisableAccount* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::RequestDisableAccount>(Arena*);
template<> ::Global::Protocol::Server::Management::RequestEnableAccount* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::RequestEnableAccount>(Arena*);
template<> ::Global::Protocol::Server::Management::RequestListAccount* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::RequestListAccount>(Arena*);
template<> ::Global::Protocol::Server::Management::RequestListBlockedAccounts* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::RequestListBlockedAccounts>(Arena*);
template<> ::Global::Protocol::Server::Management::RequestListBlockedIPAddresses* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::RequestListBlockedIPAddresses>(Arena*);
template<> ::Global::Protocol::Server::Management::RequestRemoveBlockedAccount* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::RequestRemoveBlockedAccount>(Arena*);
template<> ::Global::Protocol::Server::Management::RequestRemoveBlockedIPAddress* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::RequestRemoveBlockedIPAddress>(Arena*);
template<> ::Global::Protocol::Server::Management::ResponseAddAccount* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::ResponseAddAccount>(Arena*);
template<> ::Global::Protocol::Server::Management::ResponseAddBlockedAccount* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::ResponseAddBlockedAccount>(Arena*);
template<> ::Global::Protocol::Server::Management::ResponseAddBlockedIPAddress* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::ResponseAddBlockedIPAddress>(Arena*);
template<> ::Global::Protocol::Server::Management::ResponseChangeAccountPassword* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::ResponseChangeAccountPassword>(Arena*);
template<> ::Global::Protocol::Server::Management::ResponseDeleteAccount* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::ResponseDeleteAccount>(Arena*);
template<> ::Global::Protocol::Server::Management::ResponseDisableAccount* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::ResponseDisableAccount>(Arena*);
template<> ::Global::Protocol::Server::Management::ResponseEnableAccount* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::ResponseEnableAccount>(Arena*);
template<> ::Global::Protocol::Server::Management::ResponseListAccount* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::ResponseListAccount>(Arena*);
template<> ::Global::Protocol::Server::Management::ResponseListBlockedAccounts* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::ResponseListBlockedAccounts>(Arena*);
template<> ::Global::Protocol::Server::Management::ResponseListBlockedIPAddresses* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::ResponseListBlockedIPAddresses>(Arena*);
template<> ::Global::Protocol::Server::Management::ResponseRemoveBlockedAccount* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::ResponseRemoveBlockedAccount>(Arena*);
template<> ::Global::Protocol::Server::Management::ResponseRemoveBlockedIPAddress* Arena::CreateMaybeMessage<::Global::Protocol::Server::Management::ResponseRemoveBlockedIPAddress>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Global {
namespace Protocol {
namespace Server {
namespace Management {

// ===================================================================

class Account final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.Account) */ {
 public:
  inline Account() : Account(nullptr) {}
  ~Account() override;
  explicit constexpr Account(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Account(const Account& from);
  Account(Account&& from) noexcept
    : Account() {
    *this = ::std::move(from);
  }

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }
  inline Account& operator=(Account&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Account& default_instance() {
    return *internal_default_instance();
  }
  static inline const Account* internal_default_instance() {
    return reinterpret_cast<const Account*>(
               &_Account_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Account& a, Account& b) {
    a.Swap(&b);
  }
  inline void Swap(Account* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Account* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Account* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Account>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Account& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Account& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Account* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.Account";
  }
  protected:
  explicit Account(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kUserIdFieldNumber = 1,
    kDisabledFieldNumber = 4,
  };
  // string account = 2;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // int64 user_id = 1;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // bool disabled = 4;
  void clear_disabled();
  bool disabled() const;
  void set_disabled(bool value);
  private:
  bool _internal_disabled() const;
  void _internal_set_disabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.Account)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  int64_t user_id_;
  bool disabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class RequestListAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.RequestListAccount) */ {
 public:
  inline RequestListAccount() : RequestListAccount(nullptr) {}
  ~RequestListAccount() override;
  explicit constexpr RequestListAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestListAccount(const RequestListAccount& from);
  RequestListAccount(RequestListAccount&& from) noexcept
    : RequestListAccount() {
    *this = ::std::move(from);
  }

  inline RequestListAccount& operator=(const RequestListAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestListAccount& operator=(RequestListAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestListAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestListAccount* internal_default_instance() {
    return reinterpret_cast<const RequestListAccount*>(
               &_RequestListAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RequestListAccount& a, RequestListAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestListAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestListAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestListAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestListAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestListAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestListAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestListAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.RequestListAccount";
  }
  protected:
  explicit RequestListAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFilterFieldNumber = 2,
    kSeqFieldNumber = 1,
  };
  // string user_name_filter = 2;
  void clear_user_name_filter();
  const std::string& user_name_filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name_filter();
  PROTOBUF_NODISCARD std::string* release_user_name_filter();
  void set_allocated_user_name_filter(std::string* user_name_filter);
  private:
  const std::string& _internal_user_name_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name_filter(const std::string& value);
  std::string* _internal_mutable_user_name_filter();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.RequestListAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_filter_;
  int64_t seq_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class ResponseListAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.ResponseListAccount) */ {
 public:
  inline ResponseListAccount() : ResponseListAccount(nullptr) {}
  ~ResponseListAccount() override;
  explicit constexpr ResponseListAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseListAccount(const ResponseListAccount& from);
  ResponseListAccount(ResponseListAccount&& from) noexcept
    : ResponseListAccount() {
    *this = ::std::move(from);
  }

  inline ResponseListAccount& operator=(const ResponseListAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseListAccount& operator=(ResponseListAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseListAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseListAccount* internal_default_instance() {
    return reinterpret_cast<const ResponseListAccount*>(
               &_ResponseListAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ResponseListAccount& a, ResponseListAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseListAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseListAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseListAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseListAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseListAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseListAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseListAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.ResponseListAccount";
  }
  protected:
  explicit ResponseListAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountsFieldNumber = 4,
    kErrStringFieldNumber = 3,
    kSeqFieldNumber = 1,
    kErrCodeFieldNumber = 2,
  };
  // repeated .Global.Protocol.Server.Management.Account accounts = 4;
  int accounts_size() const;
  private:
  int _internal_accounts_size() const;
  public:
  void clear_accounts();
  ::Global::Protocol::Server::Management::Account* mutable_accounts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Global::Protocol::Server::Management::Account >*
      mutable_accounts();
  private:
  const ::Global::Protocol::Server::Management::Account& _internal_accounts(int index) const;
  ::Global::Protocol::Server::Management::Account* _internal_add_accounts();
  public:
  const ::Global::Protocol::Server::Management::Account& accounts(int index) const;
  ::Global::Protocol::Server::Management::Account* add_accounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Global::Protocol::Server::Management::Account >&
      accounts() const;

  // string err_string = 3;
  void clear_err_string();
  const std::string& err_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err_string();
  PROTOBUF_NODISCARD std::string* release_err_string();
  void set_allocated_err_string(std::string* err_string);
  private:
  const std::string& _internal_err_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err_string(const std::string& value);
  std::string* _internal_mutable_err_string();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // int32 err_code = 2;
  void clear_err_code();
  int32_t err_code() const;
  void set_err_code(int32_t value);
  private:
  int32_t _internal_err_code() const;
  void _internal_set_err_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.ResponseListAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Global::Protocol::Server::Management::Account > accounts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_string_;
  int64_t seq_;
  int32_t err_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class RequestAddAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.RequestAddAccount) */ {
 public:
  inline RequestAddAccount() : RequestAddAccount(nullptr) {}
  ~RequestAddAccount() override;
  explicit constexpr RequestAddAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestAddAccount(const RequestAddAccount& from);
  RequestAddAccount(RequestAddAccount&& from) noexcept
    : RequestAddAccount() {
    *this = ::std::move(from);
  }

  inline RequestAddAccount& operator=(const RequestAddAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestAddAccount& operator=(RequestAddAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestAddAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestAddAccount* internal_default_instance() {
    return reinterpret_cast<const RequestAddAccount*>(
               &_RequestAddAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RequestAddAccount& a, RequestAddAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestAddAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestAddAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestAddAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestAddAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestAddAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestAddAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestAddAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.RequestAddAccount";
  }
  protected:
  explicit RequestAddAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kSeqFieldNumber = 1,
  };
  // string account = 2;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.RequestAddAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  int64_t seq_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class ResponseAddAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.ResponseAddAccount) */ {
 public:
  inline ResponseAddAccount() : ResponseAddAccount(nullptr) {}
  ~ResponseAddAccount() override;
  explicit constexpr ResponseAddAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseAddAccount(const ResponseAddAccount& from);
  ResponseAddAccount(ResponseAddAccount&& from) noexcept
    : ResponseAddAccount() {
    *this = ::std::move(from);
  }

  inline ResponseAddAccount& operator=(const ResponseAddAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseAddAccount& operator=(ResponseAddAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseAddAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseAddAccount* internal_default_instance() {
    return reinterpret_cast<const ResponseAddAccount*>(
               &_ResponseAddAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ResponseAddAccount& a, ResponseAddAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseAddAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseAddAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseAddAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseAddAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseAddAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseAddAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseAddAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.ResponseAddAccount";
  }
  protected:
  explicit ResponseAddAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrStringFieldNumber = 3,
    kSeqFieldNumber = 1,
    kUserIdFieldNumber = 4,
    kErrCodeFieldNumber = 2,
  };
  // string err_string = 3;
  void clear_err_string();
  const std::string& err_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err_string();
  PROTOBUF_NODISCARD std::string* release_err_string();
  void set_allocated_err_string(std::string* err_string);
  private:
  const std::string& _internal_err_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err_string(const std::string& value);
  std::string* _internal_mutable_err_string();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // int64 user_id = 4;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // int32 err_code = 2;
  void clear_err_code();
  int32_t err_code() const;
  void set_err_code(int32_t value);
  private:
  int32_t _internal_err_code() const;
  void _internal_set_err_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.ResponseAddAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_string_;
  int64_t seq_;
  int64_t user_id_;
  int32_t err_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class RequestEnableAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.RequestEnableAccount) */ {
 public:
  inline RequestEnableAccount() : RequestEnableAccount(nullptr) {}
  ~RequestEnableAccount() override;
  explicit constexpr RequestEnableAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestEnableAccount(const RequestEnableAccount& from);
  RequestEnableAccount(RequestEnableAccount&& from) noexcept
    : RequestEnableAccount() {
    *this = ::std::move(from);
  }

  inline RequestEnableAccount& operator=(const RequestEnableAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestEnableAccount& operator=(RequestEnableAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestEnableAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestEnableAccount* internal_default_instance() {
    return reinterpret_cast<const RequestEnableAccount*>(
               &_RequestEnableAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RequestEnableAccount& a, RequestEnableAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestEnableAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestEnableAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestEnableAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestEnableAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestEnableAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestEnableAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestEnableAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.RequestEnableAccount";
  }
  protected:
  explicit RequestEnableAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 2,
    kSeqFieldNumber = 1,
  };
  // string account = 2;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.RequestEnableAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  int64_t seq_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class ResponseEnableAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.ResponseEnableAccount) */ {
 public:
  inline ResponseEnableAccount() : ResponseEnableAccount(nullptr) {}
  ~ResponseEnableAccount() override;
  explicit constexpr ResponseEnableAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseEnableAccount(const ResponseEnableAccount& from);
  ResponseEnableAccount(ResponseEnableAccount&& from) noexcept
    : ResponseEnableAccount() {
    *this = ::std::move(from);
  }

  inline ResponseEnableAccount& operator=(const ResponseEnableAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseEnableAccount& operator=(ResponseEnableAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseEnableAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseEnableAccount* internal_default_instance() {
    return reinterpret_cast<const ResponseEnableAccount*>(
               &_ResponseEnableAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ResponseEnableAccount& a, ResponseEnableAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseEnableAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseEnableAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseEnableAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseEnableAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseEnableAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseEnableAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseEnableAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.ResponseEnableAccount";
  }
  protected:
  explicit ResponseEnableAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrStringFieldNumber = 3,
    kSeqFieldNumber = 1,
    kErrCodeFieldNumber = 2,
  };
  // string err_string = 3;
  void clear_err_string();
  const std::string& err_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err_string();
  PROTOBUF_NODISCARD std::string* release_err_string();
  void set_allocated_err_string(std::string* err_string);
  private:
  const std::string& _internal_err_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err_string(const std::string& value);
  std::string* _internal_mutable_err_string();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // int32 err_code = 2;
  void clear_err_code();
  int32_t err_code() const;
  void set_err_code(int32_t value);
  private:
  int32_t _internal_err_code() const;
  void _internal_set_err_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.ResponseEnableAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_string_;
  int64_t seq_;
  int32_t err_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class RequestDisableAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.RequestDisableAccount) */ {
 public:
  inline RequestDisableAccount() : RequestDisableAccount(nullptr) {}
  ~RequestDisableAccount() override;
  explicit constexpr RequestDisableAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestDisableAccount(const RequestDisableAccount& from);
  RequestDisableAccount(RequestDisableAccount&& from) noexcept
    : RequestDisableAccount() {
    *this = ::std::move(from);
  }

  inline RequestDisableAccount& operator=(const RequestDisableAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestDisableAccount& operator=(RequestDisableAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestDisableAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestDisableAccount* internal_default_instance() {
    return reinterpret_cast<const RequestDisableAccount*>(
               &_RequestDisableAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RequestDisableAccount& a, RequestDisableAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestDisableAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestDisableAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestDisableAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestDisableAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestDisableAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestDisableAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestDisableAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.RequestDisableAccount";
  }
  protected:
  explicit RequestDisableAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 2,
    kSeqFieldNumber = 1,
  };
  // string account = 2;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.RequestDisableAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  int64_t seq_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class ResponseDisableAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.ResponseDisableAccount) */ {
 public:
  inline ResponseDisableAccount() : ResponseDisableAccount(nullptr) {}
  ~ResponseDisableAccount() override;
  explicit constexpr ResponseDisableAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseDisableAccount(const ResponseDisableAccount& from);
  ResponseDisableAccount(ResponseDisableAccount&& from) noexcept
    : ResponseDisableAccount() {
    *this = ::std::move(from);
  }

  inline ResponseDisableAccount& operator=(const ResponseDisableAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseDisableAccount& operator=(ResponseDisableAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseDisableAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseDisableAccount* internal_default_instance() {
    return reinterpret_cast<const ResponseDisableAccount*>(
               &_ResponseDisableAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ResponseDisableAccount& a, ResponseDisableAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseDisableAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseDisableAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseDisableAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseDisableAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseDisableAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseDisableAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseDisableAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.ResponseDisableAccount";
  }
  protected:
  explicit ResponseDisableAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrStringFieldNumber = 3,
    kSeqFieldNumber = 1,
    kErrCodeFieldNumber = 2,
  };
  // string err_string = 3;
  void clear_err_string();
  const std::string& err_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err_string();
  PROTOBUF_NODISCARD std::string* release_err_string();
  void set_allocated_err_string(std::string* err_string);
  private:
  const std::string& _internal_err_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err_string(const std::string& value);
  std::string* _internal_mutable_err_string();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // int32 err_code = 2;
  void clear_err_code();
  int32_t err_code() const;
  void set_err_code(int32_t value);
  private:
  int32_t _internal_err_code() const;
  void _internal_set_err_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.ResponseDisableAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_string_;
  int64_t seq_;
  int32_t err_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class RequestDeleteAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.RequestDeleteAccount) */ {
 public:
  inline RequestDeleteAccount() : RequestDeleteAccount(nullptr) {}
  ~RequestDeleteAccount() override;
  explicit constexpr RequestDeleteAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestDeleteAccount(const RequestDeleteAccount& from);
  RequestDeleteAccount(RequestDeleteAccount&& from) noexcept
    : RequestDeleteAccount() {
    *this = ::std::move(from);
  }

  inline RequestDeleteAccount& operator=(const RequestDeleteAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestDeleteAccount& operator=(RequestDeleteAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestDeleteAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestDeleteAccount* internal_default_instance() {
    return reinterpret_cast<const RequestDeleteAccount*>(
               &_RequestDeleteAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RequestDeleteAccount& a, RequestDeleteAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestDeleteAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestDeleteAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestDeleteAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestDeleteAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestDeleteAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestDeleteAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestDeleteAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.RequestDeleteAccount";
  }
  protected:
  explicit RequestDeleteAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 2,
    kSeqFieldNumber = 1,
  };
  // string account = 2;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.RequestDeleteAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  int64_t seq_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class ResponseDeleteAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.ResponseDeleteAccount) */ {
 public:
  inline ResponseDeleteAccount() : ResponseDeleteAccount(nullptr) {}
  ~ResponseDeleteAccount() override;
  explicit constexpr ResponseDeleteAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseDeleteAccount(const ResponseDeleteAccount& from);
  ResponseDeleteAccount(ResponseDeleteAccount&& from) noexcept
    : ResponseDeleteAccount() {
    *this = ::std::move(from);
  }

  inline ResponseDeleteAccount& operator=(const ResponseDeleteAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseDeleteAccount& operator=(ResponseDeleteAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseDeleteAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseDeleteAccount* internal_default_instance() {
    return reinterpret_cast<const ResponseDeleteAccount*>(
               &_ResponseDeleteAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ResponseDeleteAccount& a, ResponseDeleteAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseDeleteAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseDeleteAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseDeleteAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseDeleteAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseDeleteAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseDeleteAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseDeleteAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.ResponseDeleteAccount";
  }
  protected:
  explicit ResponseDeleteAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrStringFieldNumber = 3,
    kSeqFieldNumber = 1,
    kErrCodeFieldNumber = 2,
  };
  // string err_string = 3;
  void clear_err_string();
  const std::string& err_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err_string();
  PROTOBUF_NODISCARD std::string* release_err_string();
  void set_allocated_err_string(std::string* err_string);
  private:
  const std::string& _internal_err_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err_string(const std::string& value);
  std::string* _internal_mutable_err_string();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // int32 err_code = 2;
  void clear_err_code();
  int32_t err_code() const;
  void set_err_code(int32_t value);
  private:
  int32_t _internal_err_code() const;
  void _internal_set_err_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.ResponseDeleteAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_string_;
  int64_t seq_;
  int32_t err_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class RequestChangeAccountPassword final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.RequestChangeAccountPassword) */ {
 public:
  inline RequestChangeAccountPassword() : RequestChangeAccountPassword(nullptr) {}
  ~RequestChangeAccountPassword() override;
  explicit constexpr RequestChangeAccountPassword(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestChangeAccountPassword(const RequestChangeAccountPassword& from);
  RequestChangeAccountPassword(RequestChangeAccountPassword&& from) noexcept
    : RequestChangeAccountPassword() {
    *this = ::std::move(from);
  }

  inline RequestChangeAccountPassword& operator=(const RequestChangeAccountPassword& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestChangeAccountPassword& operator=(RequestChangeAccountPassword&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestChangeAccountPassword& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestChangeAccountPassword* internal_default_instance() {
    return reinterpret_cast<const RequestChangeAccountPassword*>(
               &_RequestChangeAccountPassword_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RequestChangeAccountPassword& a, RequestChangeAccountPassword& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestChangeAccountPassword* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestChangeAccountPassword* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestChangeAccountPassword* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestChangeAccountPassword>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestChangeAccountPassword& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestChangeAccountPassword& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestChangeAccountPassword* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.RequestChangeAccountPassword";
  }
  protected:
  explicit RequestChangeAccountPassword(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kSeqFieldNumber = 1,
  };
  // string account = 2;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.RequestChangeAccountPassword)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  int64_t seq_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class ResponseChangeAccountPassword final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.ResponseChangeAccountPassword) */ {
 public:
  inline ResponseChangeAccountPassword() : ResponseChangeAccountPassword(nullptr) {}
  ~ResponseChangeAccountPassword() override;
  explicit constexpr ResponseChangeAccountPassword(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseChangeAccountPassword(const ResponseChangeAccountPassword& from);
  ResponseChangeAccountPassword(ResponseChangeAccountPassword&& from) noexcept
    : ResponseChangeAccountPassword() {
    *this = ::std::move(from);
  }

  inline ResponseChangeAccountPassword& operator=(const ResponseChangeAccountPassword& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseChangeAccountPassword& operator=(ResponseChangeAccountPassword&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseChangeAccountPassword& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseChangeAccountPassword* internal_default_instance() {
    return reinterpret_cast<const ResponseChangeAccountPassword*>(
               &_ResponseChangeAccountPassword_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ResponseChangeAccountPassword& a, ResponseChangeAccountPassword& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseChangeAccountPassword* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseChangeAccountPassword* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseChangeAccountPassword* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseChangeAccountPassword>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseChangeAccountPassword& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseChangeAccountPassword& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseChangeAccountPassword* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.ResponseChangeAccountPassword";
  }
  protected:
  explicit ResponseChangeAccountPassword(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrStringFieldNumber = 3,
    kSeqFieldNumber = 1,
    kErrCodeFieldNumber = 2,
  };
  // string err_string = 3;
  void clear_err_string();
  const std::string& err_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err_string();
  PROTOBUF_NODISCARD std::string* release_err_string();
  void set_allocated_err_string(std::string* err_string);
  private:
  const std::string& _internal_err_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err_string(const std::string& value);
  std::string* _internal_mutable_err_string();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // int32 err_code = 2;
  void clear_err_code();
  int32_t err_code() const;
  void set_err_code(int32_t value);
  private:
  int32_t _internal_err_code() const;
  void _internal_set_err_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.ResponseChangeAccountPassword)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_string_;
  int64_t seq_;
  int32_t err_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class RequestListBlockedIPAddresses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.RequestListBlockedIPAddresses) */ {
 public:
  inline RequestListBlockedIPAddresses() : RequestListBlockedIPAddresses(nullptr) {}
  ~RequestListBlockedIPAddresses() override;
  explicit constexpr RequestListBlockedIPAddresses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestListBlockedIPAddresses(const RequestListBlockedIPAddresses& from);
  RequestListBlockedIPAddresses(RequestListBlockedIPAddresses&& from) noexcept
    : RequestListBlockedIPAddresses() {
    *this = ::std::move(from);
  }

  inline RequestListBlockedIPAddresses& operator=(const RequestListBlockedIPAddresses& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestListBlockedIPAddresses& operator=(RequestListBlockedIPAddresses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestListBlockedIPAddresses& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestListBlockedIPAddresses* internal_default_instance() {
    return reinterpret_cast<const RequestListBlockedIPAddresses*>(
               &_RequestListBlockedIPAddresses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RequestListBlockedIPAddresses& a, RequestListBlockedIPAddresses& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestListBlockedIPAddresses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestListBlockedIPAddresses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestListBlockedIPAddresses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestListBlockedIPAddresses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestListBlockedIPAddresses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestListBlockedIPAddresses& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestListBlockedIPAddresses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.RequestListBlockedIPAddresses";
  }
  protected:
  explicit RequestListBlockedIPAddresses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqFieldNumber = 1,
  };
  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.RequestListBlockedIPAddresses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t seq_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class BlockedIPAddress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.BlockedIPAddress) */ {
 public:
  inline BlockedIPAddress() : BlockedIPAddress(nullptr) {}
  ~BlockedIPAddress() override;
  explicit constexpr BlockedIPAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockedIPAddress(const BlockedIPAddress& from);
  BlockedIPAddress(BlockedIPAddress&& from) noexcept
    : BlockedIPAddress() {
    *this = ::std::move(from);
  }

  inline BlockedIPAddress& operator=(const BlockedIPAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockedIPAddress& operator=(BlockedIPAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockedIPAddress& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockedIPAddress* internal_default_instance() {
    return reinterpret_cast<const BlockedIPAddress*>(
               &_BlockedIPAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BlockedIPAddress& a, BlockedIPAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockedIPAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockedIPAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockedIPAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockedIPAddress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockedIPAddress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockedIPAddress& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockedIPAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.BlockedIPAddress";
  }
  protected:
  explicit BlockedIPAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddressFieldNumber = 1,
    kUntilFieldNumber = 2,
  };
  // string ip_address = 1;
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // int64 until = 2;
  void clear_until();
  int64_t until() const;
  void set_until(int64_t value);
  private:
  int64_t _internal_until() const;
  void _internal_set_until(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.BlockedIPAddress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
  int64_t until_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class ResponseListBlockedIPAddresses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.ResponseListBlockedIPAddresses) */ {
 public:
  inline ResponseListBlockedIPAddresses() : ResponseListBlockedIPAddresses(nullptr) {}
  ~ResponseListBlockedIPAddresses() override;
  explicit constexpr ResponseListBlockedIPAddresses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseListBlockedIPAddresses(const ResponseListBlockedIPAddresses& from);
  ResponseListBlockedIPAddresses(ResponseListBlockedIPAddresses&& from) noexcept
    : ResponseListBlockedIPAddresses() {
    *this = ::std::move(from);
  }

  inline ResponseListBlockedIPAddresses& operator=(const ResponseListBlockedIPAddresses& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseListBlockedIPAddresses& operator=(ResponseListBlockedIPAddresses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseListBlockedIPAddresses& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseListBlockedIPAddresses* internal_default_instance() {
    return reinterpret_cast<const ResponseListBlockedIPAddresses*>(
               &_ResponseListBlockedIPAddresses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ResponseListBlockedIPAddresses& a, ResponseListBlockedIPAddresses& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseListBlockedIPAddresses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseListBlockedIPAddresses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseListBlockedIPAddresses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseListBlockedIPAddresses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseListBlockedIPAddresses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseListBlockedIPAddresses& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseListBlockedIPAddresses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.ResponseListBlockedIPAddresses";
  }
  protected:
  explicit ResponseListBlockedIPAddresses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddressesFieldNumber = 4,
    kErrStringFieldNumber = 3,
    kSeqFieldNumber = 1,
    kErrCodeFieldNumber = 2,
  };
  // repeated .Global.Protocol.Server.Management.BlockedIPAddress ip_addresses = 4;
  int ip_addresses_size() const;
  private:
  int _internal_ip_addresses_size() const;
  public:
  void clear_ip_addresses();
  ::Global::Protocol::Server::Management::BlockedIPAddress* mutable_ip_addresses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Global::Protocol::Server::Management::BlockedIPAddress >*
      mutable_ip_addresses();
  private:
  const ::Global::Protocol::Server::Management::BlockedIPAddress& _internal_ip_addresses(int index) const;
  ::Global::Protocol::Server::Management::BlockedIPAddress* _internal_add_ip_addresses();
  public:
  const ::Global::Protocol::Server::Management::BlockedIPAddress& ip_addresses(int index) const;
  ::Global::Protocol::Server::Management::BlockedIPAddress* add_ip_addresses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Global::Protocol::Server::Management::BlockedIPAddress >&
      ip_addresses() const;

  // string err_string = 3;
  void clear_err_string();
  const std::string& err_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err_string();
  PROTOBUF_NODISCARD std::string* release_err_string();
  void set_allocated_err_string(std::string* err_string);
  private:
  const std::string& _internal_err_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err_string(const std::string& value);
  std::string* _internal_mutable_err_string();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // int32 err_code = 2;
  void clear_err_code();
  int32_t err_code() const;
  void set_err_code(int32_t value);
  private:
  int32_t _internal_err_code() const;
  void _internal_set_err_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.ResponseListBlockedIPAddresses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Global::Protocol::Server::Management::BlockedIPAddress > ip_addresses_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_string_;
  int64_t seq_;
  int32_t err_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class RequestRemoveBlockedIPAddress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.RequestRemoveBlockedIPAddress) */ {
 public:
  inline RequestRemoveBlockedIPAddress() : RequestRemoveBlockedIPAddress(nullptr) {}
  ~RequestRemoveBlockedIPAddress() override;
  explicit constexpr RequestRemoveBlockedIPAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestRemoveBlockedIPAddress(const RequestRemoveBlockedIPAddress& from);
  RequestRemoveBlockedIPAddress(RequestRemoveBlockedIPAddress&& from) noexcept
    : RequestRemoveBlockedIPAddress() {
    *this = ::std::move(from);
  }

  inline RequestRemoveBlockedIPAddress& operator=(const RequestRemoveBlockedIPAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestRemoveBlockedIPAddress& operator=(RequestRemoveBlockedIPAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestRemoveBlockedIPAddress& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestRemoveBlockedIPAddress* internal_default_instance() {
    return reinterpret_cast<const RequestRemoveBlockedIPAddress*>(
               &_RequestRemoveBlockedIPAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RequestRemoveBlockedIPAddress& a, RequestRemoveBlockedIPAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestRemoveBlockedIPAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestRemoveBlockedIPAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestRemoveBlockedIPAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestRemoveBlockedIPAddress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestRemoveBlockedIPAddress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestRemoveBlockedIPAddress& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestRemoveBlockedIPAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.RequestRemoveBlockedIPAddress";
  }
  protected:
  explicit RequestRemoveBlockedIPAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddressFieldNumber = 2,
    kSeqFieldNumber = 1,
  };
  // string ip_address = 2;
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.RequestRemoveBlockedIPAddress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
  int64_t seq_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class ResponseRemoveBlockedIPAddress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.ResponseRemoveBlockedIPAddress) */ {
 public:
  inline ResponseRemoveBlockedIPAddress() : ResponseRemoveBlockedIPAddress(nullptr) {}
  ~ResponseRemoveBlockedIPAddress() override;
  explicit constexpr ResponseRemoveBlockedIPAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseRemoveBlockedIPAddress(const ResponseRemoveBlockedIPAddress& from);
  ResponseRemoveBlockedIPAddress(ResponseRemoveBlockedIPAddress&& from) noexcept
    : ResponseRemoveBlockedIPAddress() {
    *this = ::std::move(from);
  }

  inline ResponseRemoveBlockedIPAddress& operator=(const ResponseRemoveBlockedIPAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseRemoveBlockedIPAddress& operator=(ResponseRemoveBlockedIPAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseRemoveBlockedIPAddress& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseRemoveBlockedIPAddress* internal_default_instance() {
    return reinterpret_cast<const ResponseRemoveBlockedIPAddress*>(
               &_ResponseRemoveBlockedIPAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ResponseRemoveBlockedIPAddress& a, ResponseRemoveBlockedIPAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseRemoveBlockedIPAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseRemoveBlockedIPAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseRemoveBlockedIPAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseRemoveBlockedIPAddress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseRemoveBlockedIPAddress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseRemoveBlockedIPAddress& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseRemoveBlockedIPAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.ResponseRemoveBlockedIPAddress";
  }
  protected:
  explicit ResponseRemoveBlockedIPAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrStringFieldNumber = 3,
    kSeqFieldNumber = 1,
    kErrCodeFieldNumber = 2,
  };
  // string err_string = 3;
  void clear_err_string();
  const std::string& err_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err_string();
  PROTOBUF_NODISCARD std::string* release_err_string();
  void set_allocated_err_string(std::string* err_string);
  private:
  const std::string& _internal_err_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err_string(const std::string& value);
  std::string* _internal_mutable_err_string();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // int32 err_code = 2;
  void clear_err_code();
  int32_t err_code() const;
  void set_err_code(int32_t value);
  private:
  int32_t _internal_err_code() const;
  void _internal_set_err_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.ResponseRemoveBlockedIPAddress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_string_;
  int64_t seq_;
  int32_t err_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class RequestAddBlockedIPAddress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.RequestAddBlockedIPAddress) */ {
 public:
  inline RequestAddBlockedIPAddress() : RequestAddBlockedIPAddress(nullptr) {}
  ~RequestAddBlockedIPAddress() override;
  explicit constexpr RequestAddBlockedIPAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestAddBlockedIPAddress(const RequestAddBlockedIPAddress& from);
  RequestAddBlockedIPAddress(RequestAddBlockedIPAddress&& from) noexcept
    : RequestAddBlockedIPAddress() {
    *this = ::std::move(from);
  }

  inline RequestAddBlockedIPAddress& operator=(const RequestAddBlockedIPAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestAddBlockedIPAddress& operator=(RequestAddBlockedIPAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestAddBlockedIPAddress& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestAddBlockedIPAddress* internal_default_instance() {
    return reinterpret_cast<const RequestAddBlockedIPAddress*>(
               &_RequestAddBlockedIPAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RequestAddBlockedIPAddress& a, RequestAddBlockedIPAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestAddBlockedIPAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestAddBlockedIPAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestAddBlockedIPAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestAddBlockedIPAddress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestAddBlockedIPAddress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestAddBlockedIPAddress& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestAddBlockedIPAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.RequestAddBlockedIPAddress";
  }
  protected:
  explicit RequestAddBlockedIPAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddressFieldNumber = 2,
    kSeqFieldNumber = 1,
    kDurationFieldNumber = 3,
  };
  // string ip_address = 2;
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // int32 duration = 3;
  void clear_duration();
  int32_t duration() const;
  void set_duration(int32_t value);
  private:
  int32_t _internal_duration() const;
  void _internal_set_duration(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.RequestAddBlockedIPAddress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
  int64_t seq_;
  int32_t duration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class ResponseAddBlockedIPAddress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.ResponseAddBlockedIPAddress) */ {
 public:
  inline ResponseAddBlockedIPAddress() : ResponseAddBlockedIPAddress(nullptr) {}
  ~ResponseAddBlockedIPAddress() override;
  explicit constexpr ResponseAddBlockedIPAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseAddBlockedIPAddress(const ResponseAddBlockedIPAddress& from);
  ResponseAddBlockedIPAddress(ResponseAddBlockedIPAddress&& from) noexcept
    : ResponseAddBlockedIPAddress() {
    *this = ::std::move(from);
  }

  inline ResponseAddBlockedIPAddress& operator=(const ResponseAddBlockedIPAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseAddBlockedIPAddress& operator=(ResponseAddBlockedIPAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseAddBlockedIPAddress& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseAddBlockedIPAddress* internal_default_instance() {
    return reinterpret_cast<const ResponseAddBlockedIPAddress*>(
               &_ResponseAddBlockedIPAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ResponseAddBlockedIPAddress& a, ResponseAddBlockedIPAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseAddBlockedIPAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseAddBlockedIPAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseAddBlockedIPAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseAddBlockedIPAddress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseAddBlockedIPAddress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseAddBlockedIPAddress& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseAddBlockedIPAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.ResponseAddBlockedIPAddress";
  }
  protected:
  explicit ResponseAddBlockedIPAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrStringFieldNumber = 3,
    kSeqFieldNumber = 1,
    kErrCodeFieldNumber = 2,
  };
  // string err_string = 3;
  void clear_err_string();
  const std::string& err_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err_string();
  PROTOBUF_NODISCARD std::string* release_err_string();
  void set_allocated_err_string(std::string* err_string);
  private:
  const std::string& _internal_err_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err_string(const std::string& value);
  std::string* _internal_mutable_err_string();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // int32 err_code = 2;
  void clear_err_code();
  int32_t err_code() const;
  void set_err_code(int32_t value);
  private:
  int32_t _internal_err_code() const;
  void _internal_set_err_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.ResponseAddBlockedIPAddress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_string_;
  int64_t seq_;
  int32_t err_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class RequestListBlockedAccounts final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.RequestListBlockedAccounts) */ {
 public:
  inline RequestListBlockedAccounts() : RequestListBlockedAccounts(nullptr) {}
  ~RequestListBlockedAccounts() override;
  explicit constexpr RequestListBlockedAccounts(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestListBlockedAccounts(const RequestListBlockedAccounts& from);
  RequestListBlockedAccounts(RequestListBlockedAccounts&& from) noexcept
    : RequestListBlockedAccounts() {
    *this = ::std::move(from);
  }

  inline RequestListBlockedAccounts& operator=(const RequestListBlockedAccounts& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestListBlockedAccounts& operator=(RequestListBlockedAccounts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestListBlockedAccounts& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestListBlockedAccounts* internal_default_instance() {
    return reinterpret_cast<const RequestListBlockedAccounts*>(
               &_RequestListBlockedAccounts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RequestListBlockedAccounts& a, RequestListBlockedAccounts& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestListBlockedAccounts* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestListBlockedAccounts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestListBlockedAccounts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestListBlockedAccounts>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestListBlockedAccounts& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestListBlockedAccounts& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestListBlockedAccounts* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.RequestListBlockedAccounts";
  }
  protected:
  explicit RequestListBlockedAccounts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqFieldNumber = 1,
  };
  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.RequestListBlockedAccounts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t seq_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class BlockedAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.BlockedAccount) */ {
 public:
  inline BlockedAccount() : BlockedAccount(nullptr) {}
  ~BlockedAccount() override;
  explicit constexpr BlockedAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockedAccount(const BlockedAccount& from);
  BlockedAccount(BlockedAccount&& from) noexcept
    : BlockedAccount() {
    *this = ::std::move(from);
  }

  inline BlockedAccount& operator=(const BlockedAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockedAccount& operator=(BlockedAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockedAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockedAccount* internal_default_instance() {
    return reinterpret_cast<const BlockedAccount*>(
               &_BlockedAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(BlockedAccount& a, BlockedAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockedAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockedAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockedAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockedAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockedAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockedAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockedAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.BlockedAccount";
  }
  protected:
  explicit BlockedAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 2,
    kUserIdFieldNumber = 1,
    kUntilFieldNumber = 3,
  };
  // string account = 2;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // int64 user_id = 1;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // int64 until = 3;
  void clear_until();
  int64_t until() const;
  void set_until(int64_t value);
  private:
  int64_t _internal_until() const;
  void _internal_set_until(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.BlockedAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  int64_t user_id_;
  int64_t until_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class ResponseListBlockedAccounts final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.ResponseListBlockedAccounts) */ {
 public:
  inline ResponseListBlockedAccounts() : ResponseListBlockedAccounts(nullptr) {}
  ~ResponseListBlockedAccounts() override;
  explicit constexpr ResponseListBlockedAccounts(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseListBlockedAccounts(const ResponseListBlockedAccounts& from);
  ResponseListBlockedAccounts(ResponseListBlockedAccounts&& from) noexcept
    : ResponseListBlockedAccounts() {
    *this = ::std::move(from);
  }

  inline ResponseListBlockedAccounts& operator=(const ResponseListBlockedAccounts& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseListBlockedAccounts& operator=(ResponseListBlockedAccounts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseListBlockedAccounts& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseListBlockedAccounts* internal_default_instance() {
    return reinterpret_cast<const ResponseListBlockedAccounts*>(
               &_ResponseListBlockedAccounts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ResponseListBlockedAccounts& a, ResponseListBlockedAccounts& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseListBlockedAccounts* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseListBlockedAccounts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseListBlockedAccounts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseListBlockedAccounts>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseListBlockedAccounts& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseListBlockedAccounts& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseListBlockedAccounts* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.ResponseListBlockedAccounts";
  }
  protected:
  explicit ResponseListBlockedAccounts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountsFieldNumber = 4,
    kErrStringFieldNumber = 3,
    kSeqFieldNumber = 1,
    kErrCodeFieldNumber = 2,
  };
  // repeated .Global.Protocol.Server.Management.BlockedAccount accounts = 4;
  int accounts_size() const;
  private:
  int _internal_accounts_size() const;
  public:
  void clear_accounts();
  ::Global::Protocol::Server::Management::BlockedAccount* mutable_accounts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Global::Protocol::Server::Management::BlockedAccount >*
      mutable_accounts();
  private:
  const ::Global::Protocol::Server::Management::BlockedAccount& _internal_accounts(int index) const;
  ::Global::Protocol::Server::Management::BlockedAccount* _internal_add_accounts();
  public:
  const ::Global::Protocol::Server::Management::BlockedAccount& accounts(int index) const;
  ::Global::Protocol::Server::Management::BlockedAccount* add_accounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Global::Protocol::Server::Management::BlockedAccount >&
      accounts() const;

  // string err_string = 3;
  void clear_err_string();
  const std::string& err_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err_string();
  PROTOBUF_NODISCARD std::string* release_err_string();
  void set_allocated_err_string(std::string* err_string);
  private:
  const std::string& _internal_err_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err_string(const std::string& value);
  std::string* _internal_mutable_err_string();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // int32 err_code = 2;
  void clear_err_code();
  int32_t err_code() const;
  void set_err_code(int32_t value);
  private:
  int32_t _internal_err_code() const;
  void _internal_set_err_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.ResponseListBlockedAccounts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Global::Protocol::Server::Management::BlockedAccount > accounts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_string_;
  int64_t seq_;
  int32_t err_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class RequestRemoveBlockedAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.RequestRemoveBlockedAccount) */ {
 public:
  inline RequestRemoveBlockedAccount() : RequestRemoveBlockedAccount(nullptr) {}
  ~RequestRemoveBlockedAccount() override;
  explicit constexpr RequestRemoveBlockedAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestRemoveBlockedAccount(const RequestRemoveBlockedAccount& from);
  RequestRemoveBlockedAccount(RequestRemoveBlockedAccount&& from) noexcept
    : RequestRemoveBlockedAccount() {
    *this = ::std::move(from);
  }

  inline RequestRemoveBlockedAccount& operator=(const RequestRemoveBlockedAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestRemoveBlockedAccount& operator=(RequestRemoveBlockedAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestRemoveBlockedAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestRemoveBlockedAccount* internal_default_instance() {
    return reinterpret_cast<const RequestRemoveBlockedAccount*>(
               &_RequestRemoveBlockedAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(RequestRemoveBlockedAccount& a, RequestRemoveBlockedAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestRemoveBlockedAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestRemoveBlockedAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestRemoveBlockedAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestRemoveBlockedAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestRemoveBlockedAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestRemoveBlockedAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestRemoveBlockedAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.RequestRemoveBlockedAccount";
  }
  protected:
  explicit RequestRemoveBlockedAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqFieldNumber = 1,
    kUserIdFieldNumber = 2,
  };
  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // int64 user_id = 2;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.RequestRemoveBlockedAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t seq_;
  int64_t user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class ResponseRemoveBlockedAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.ResponseRemoveBlockedAccount) */ {
 public:
  inline ResponseRemoveBlockedAccount() : ResponseRemoveBlockedAccount(nullptr) {}
  ~ResponseRemoveBlockedAccount() override;
  explicit constexpr ResponseRemoveBlockedAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseRemoveBlockedAccount(const ResponseRemoveBlockedAccount& from);
  ResponseRemoveBlockedAccount(ResponseRemoveBlockedAccount&& from) noexcept
    : ResponseRemoveBlockedAccount() {
    *this = ::std::move(from);
  }

  inline ResponseRemoveBlockedAccount& operator=(const ResponseRemoveBlockedAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseRemoveBlockedAccount& operator=(ResponseRemoveBlockedAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseRemoveBlockedAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseRemoveBlockedAccount* internal_default_instance() {
    return reinterpret_cast<const ResponseRemoveBlockedAccount*>(
               &_ResponseRemoveBlockedAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ResponseRemoveBlockedAccount& a, ResponseRemoveBlockedAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseRemoveBlockedAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseRemoveBlockedAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseRemoveBlockedAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseRemoveBlockedAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseRemoveBlockedAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseRemoveBlockedAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseRemoveBlockedAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.ResponseRemoveBlockedAccount";
  }
  protected:
  explicit ResponseRemoveBlockedAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrStringFieldNumber = 3,
    kSeqFieldNumber = 1,
    kErrCodeFieldNumber = 2,
  };
  // string err_string = 3;
  void clear_err_string();
  const std::string& err_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err_string();
  PROTOBUF_NODISCARD std::string* release_err_string();
  void set_allocated_err_string(std::string* err_string);
  private:
  const std::string& _internal_err_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err_string(const std::string& value);
  std::string* _internal_mutable_err_string();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // int32 err_code = 2;
  void clear_err_code();
  int32_t err_code() const;
  void set_err_code(int32_t value);
  private:
  int32_t _internal_err_code() const;
  void _internal_set_err_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.ResponseRemoveBlockedAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_string_;
  int64_t seq_;
  int32_t err_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class RequestAddBlockedAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.RequestAddBlockedAccount) */ {
 public:
  inline RequestAddBlockedAccount() : RequestAddBlockedAccount(nullptr) {}
  ~RequestAddBlockedAccount() override;
  explicit constexpr RequestAddBlockedAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestAddBlockedAccount(const RequestAddBlockedAccount& from);
  RequestAddBlockedAccount(RequestAddBlockedAccount&& from) noexcept
    : RequestAddBlockedAccount() {
    *this = ::std::move(from);
  }

  inline RequestAddBlockedAccount& operator=(const RequestAddBlockedAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestAddBlockedAccount& operator=(RequestAddBlockedAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestAddBlockedAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestAddBlockedAccount* internal_default_instance() {
    return reinterpret_cast<const RequestAddBlockedAccount*>(
               &_RequestAddBlockedAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(RequestAddBlockedAccount& a, RequestAddBlockedAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestAddBlockedAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestAddBlockedAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestAddBlockedAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestAddBlockedAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestAddBlockedAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestAddBlockedAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestAddBlockedAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.RequestAddBlockedAccount";
  }
  protected:
  explicit RequestAddBlockedAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kDurationFieldNumber = 3,
  };
  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // int64 user_id = 2;
  void clear_user_id();
  int64_t user_id() const;
  void set_user_id(int64_t value);
  private:
  int64_t _internal_user_id() const;
  void _internal_set_user_id(int64_t value);
  public:

  // int32 duration = 3;
  void clear_duration();
  int32_t duration() const;
  void set_duration(int32_t value);
  private:
  int32_t _internal_duration() const;
  void _internal_set_duration(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.RequestAddBlockedAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t seq_;
  int64_t user_id_;
  int32_t duration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// -------------------------------------------------------------------

class ResponseAddBlockedAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Server.Management.ResponseAddBlockedAccount) */ {
 public:
  inline ResponseAddBlockedAccount() : ResponseAddBlockedAccount(nullptr) {}
  ~ResponseAddBlockedAccount() override;
  explicit constexpr ResponseAddBlockedAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseAddBlockedAccount(const ResponseAddBlockedAccount& from);
  ResponseAddBlockedAccount(ResponseAddBlockedAccount&& from) noexcept
    : ResponseAddBlockedAccount() {
    *this = ::std::move(from);
  }

  inline ResponseAddBlockedAccount& operator=(const ResponseAddBlockedAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseAddBlockedAccount& operator=(ResponseAddBlockedAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseAddBlockedAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseAddBlockedAccount* internal_default_instance() {
    return reinterpret_cast<const ResponseAddBlockedAccount*>(
               &_ResponseAddBlockedAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ResponseAddBlockedAccount& a, ResponseAddBlockedAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseAddBlockedAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseAddBlockedAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseAddBlockedAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseAddBlockedAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseAddBlockedAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseAddBlockedAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseAddBlockedAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Server.Management.ResponseAddBlockedAccount";
  }
  protected:
  explicit ResponseAddBlockedAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrStringFieldNumber = 3,
    kSeqFieldNumber = 1,
    kErrCodeFieldNumber = 2,
  };
  // string err_string = 3;
  void clear_err_string();
  const std::string& err_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err_string();
  PROTOBUF_NODISCARD std::string* release_err_string();
  void set_allocated_err_string(std::string* err_string);
  private:
  const std::string& _internal_err_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err_string(const std::string& value);
  std::string* _internal_mutable_err_string();
  public:

  // int64 seq = 1;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // int32 err_code = 2;
  void clear_err_code();
  int32_t err_code() const;
  void set_err_code(int32_t value);
  private:
  int32_t _internal_err_code() const;
  void _internal_set_err_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Server.Management.ResponseAddBlockedAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_string_;
  int64_t seq_;
  int32_t err_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Management_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Account

// int64 user_id = 1;
inline void Account::clear_user_id() {
  user_id_ = int64_t{0};
}
inline int64_t Account::_internal_user_id() const {
  return user_id_;
}
inline int64_t Account::user_id() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.Account.user_id)
  return _internal_user_id();
}
inline void Account::_internal_set_user_id(int64_t value) {
  
  user_id_ = value;
}
inline void Account::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.Account.user_id)
}

// string account = 2;
inline void Account::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& Account::account() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.Account.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Account::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.Account.account)
}
inline std::string* Account::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.Account.account)
  return _s;
}
inline const std::string& Account::_internal_account() const {
  return account_.Get();
}
inline void Account::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Account::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Account::release_account() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.Account.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Account::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.Account.account)
}

// string password = 3;
inline void Account::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& Account::password() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.Account.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Account::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.Account.password)
}
inline std::string* Account::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.Account.password)
  return _s;
}
inline const std::string& Account::_internal_password() const {
  return password_.Get();
}
inline void Account::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Account::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Account::release_password() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.Account.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Account::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.Account.password)
}

// bool disabled = 4;
inline void Account::clear_disabled() {
  disabled_ = false;
}
inline bool Account::_internal_disabled() const {
  return disabled_;
}
inline bool Account::disabled() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.Account.disabled)
  return _internal_disabled();
}
inline void Account::_internal_set_disabled(bool value) {
  
  disabled_ = value;
}
inline void Account::set_disabled(bool value) {
  _internal_set_disabled(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.Account.disabled)
}

// -------------------------------------------------------------------

// RequestListAccount

// int64 seq = 1;
inline void RequestListAccount::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t RequestListAccount::_internal_seq() const {
  return seq_;
}
inline int64_t RequestListAccount::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestListAccount.seq)
  return _internal_seq();
}
inline void RequestListAccount::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void RequestListAccount::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestListAccount.seq)
}

// string user_name_filter = 2;
inline void RequestListAccount::clear_user_name_filter() {
  user_name_filter_.ClearToEmpty();
}
inline const std::string& RequestListAccount::user_name_filter() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestListAccount.user_name_filter)
  return _internal_user_name_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestListAccount::set_user_name_filter(ArgT0&& arg0, ArgT... args) {
 
 user_name_filter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestListAccount.user_name_filter)
}
inline std::string* RequestListAccount::mutable_user_name_filter() {
  std::string* _s = _internal_mutable_user_name_filter();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.RequestListAccount.user_name_filter)
  return _s;
}
inline const std::string& RequestListAccount::_internal_user_name_filter() const {
  return user_name_filter_.Get();
}
inline void RequestListAccount::_internal_set_user_name_filter(const std::string& value) {
  
  user_name_filter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestListAccount::_internal_mutable_user_name_filter() {
  
  return user_name_filter_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestListAccount::release_user_name_filter() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.RequestListAccount.user_name_filter)
  return user_name_filter_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestListAccount::set_allocated_user_name_filter(std::string* user_name_filter) {
  if (user_name_filter != nullptr) {
    
  } else {
    
  }
  user_name_filter_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_name_filter,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_name_filter_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_name_filter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.RequestListAccount.user_name_filter)
}

// -------------------------------------------------------------------

// ResponseListAccount

// int64 seq = 1;
inline void ResponseListAccount::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t ResponseListAccount::_internal_seq() const {
  return seq_;
}
inline int64_t ResponseListAccount::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseListAccount.seq)
  return _internal_seq();
}
inline void ResponseListAccount::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void ResponseListAccount::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseListAccount.seq)
}

// int32 err_code = 2;
inline void ResponseListAccount::clear_err_code() {
  err_code_ = 0;
}
inline int32_t ResponseListAccount::_internal_err_code() const {
  return err_code_;
}
inline int32_t ResponseListAccount::err_code() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseListAccount.err_code)
  return _internal_err_code();
}
inline void ResponseListAccount::_internal_set_err_code(int32_t value) {
  
  err_code_ = value;
}
inline void ResponseListAccount::set_err_code(int32_t value) {
  _internal_set_err_code(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseListAccount.err_code)
}

// string err_string = 3;
inline void ResponseListAccount::clear_err_string() {
  err_string_.ClearToEmpty();
}
inline const std::string& ResponseListAccount::err_string() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseListAccount.err_string)
  return _internal_err_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseListAccount::set_err_string(ArgT0&& arg0, ArgT... args) {
 
 err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseListAccount.err_string)
}
inline std::string* ResponseListAccount::mutable_err_string() {
  std::string* _s = _internal_mutable_err_string();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.ResponseListAccount.err_string)
  return _s;
}
inline const std::string& ResponseListAccount::_internal_err_string() const {
  return err_string_.Get();
}
inline void ResponseListAccount::_internal_set_err_string(const std::string& value) {
  
  err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseListAccount::_internal_mutable_err_string() {
  
  return err_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseListAccount::release_err_string() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.ResponseListAccount.err_string)
  return err_string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseListAccount::set_allocated_err_string(std::string* err_string) {
  if (err_string != nullptr) {
    
  } else {
    
  }
  err_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), err_string,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (err_string_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    err_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.ResponseListAccount.err_string)
}

// repeated .Global.Protocol.Server.Management.Account accounts = 4;
inline int ResponseListAccount::_internal_accounts_size() const {
  return accounts_.size();
}
inline int ResponseListAccount::accounts_size() const {
  return _internal_accounts_size();
}
inline void ResponseListAccount::clear_accounts() {
  accounts_.Clear();
}
inline ::Global::Protocol::Server::Management::Account* ResponseListAccount::mutable_accounts(int index) {
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.ResponseListAccount.accounts)
  return accounts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Global::Protocol::Server::Management::Account >*
ResponseListAccount::mutable_accounts() {
  // @@protoc_insertion_point(field_mutable_list:Global.Protocol.Server.Management.ResponseListAccount.accounts)
  return &accounts_;
}
inline const ::Global::Protocol::Server::Management::Account& ResponseListAccount::_internal_accounts(int index) const {
  return accounts_.Get(index);
}
inline const ::Global::Protocol::Server::Management::Account& ResponseListAccount::accounts(int index) const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseListAccount.accounts)
  return _internal_accounts(index);
}
inline ::Global::Protocol::Server::Management::Account* ResponseListAccount::_internal_add_accounts() {
  return accounts_.Add();
}
inline ::Global::Protocol::Server::Management::Account* ResponseListAccount::add_accounts() {
  ::Global::Protocol::Server::Management::Account* _add = _internal_add_accounts();
  // @@protoc_insertion_point(field_add:Global.Protocol.Server.Management.ResponseListAccount.accounts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Global::Protocol::Server::Management::Account >&
ResponseListAccount::accounts() const {
  // @@protoc_insertion_point(field_list:Global.Protocol.Server.Management.ResponseListAccount.accounts)
  return accounts_;
}

// -------------------------------------------------------------------

// RequestAddAccount

// int64 seq = 1;
inline void RequestAddAccount::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t RequestAddAccount::_internal_seq() const {
  return seq_;
}
inline int64_t RequestAddAccount::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestAddAccount.seq)
  return _internal_seq();
}
inline void RequestAddAccount::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void RequestAddAccount::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestAddAccount.seq)
}

// string account = 2;
inline void RequestAddAccount::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& RequestAddAccount::account() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestAddAccount.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestAddAccount::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestAddAccount.account)
}
inline std::string* RequestAddAccount::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.RequestAddAccount.account)
  return _s;
}
inline const std::string& RequestAddAccount::_internal_account() const {
  return account_.Get();
}
inline void RequestAddAccount::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestAddAccount::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestAddAccount::release_account() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.RequestAddAccount.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestAddAccount::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.RequestAddAccount.account)
}

// string password = 3;
inline void RequestAddAccount::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& RequestAddAccount::password() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestAddAccount.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestAddAccount::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestAddAccount.password)
}
inline std::string* RequestAddAccount::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.RequestAddAccount.password)
  return _s;
}
inline const std::string& RequestAddAccount::_internal_password() const {
  return password_.Get();
}
inline void RequestAddAccount::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestAddAccount::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestAddAccount::release_password() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.RequestAddAccount.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestAddAccount::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.RequestAddAccount.password)
}

// -------------------------------------------------------------------

// ResponseAddAccount

// int64 seq = 1;
inline void ResponseAddAccount::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t ResponseAddAccount::_internal_seq() const {
  return seq_;
}
inline int64_t ResponseAddAccount::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseAddAccount.seq)
  return _internal_seq();
}
inline void ResponseAddAccount::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void ResponseAddAccount::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseAddAccount.seq)
}

// int32 err_code = 2;
inline void ResponseAddAccount::clear_err_code() {
  err_code_ = 0;
}
inline int32_t ResponseAddAccount::_internal_err_code() const {
  return err_code_;
}
inline int32_t ResponseAddAccount::err_code() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseAddAccount.err_code)
  return _internal_err_code();
}
inline void ResponseAddAccount::_internal_set_err_code(int32_t value) {
  
  err_code_ = value;
}
inline void ResponseAddAccount::set_err_code(int32_t value) {
  _internal_set_err_code(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseAddAccount.err_code)
}

// string err_string = 3;
inline void ResponseAddAccount::clear_err_string() {
  err_string_.ClearToEmpty();
}
inline const std::string& ResponseAddAccount::err_string() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseAddAccount.err_string)
  return _internal_err_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseAddAccount::set_err_string(ArgT0&& arg0, ArgT... args) {
 
 err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseAddAccount.err_string)
}
inline std::string* ResponseAddAccount::mutable_err_string() {
  std::string* _s = _internal_mutable_err_string();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.ResponseAddAccount.err_string)
  return _s;
}
inline const std::string& ResponseAddAccount::_internal_err_string() const {
  return err_string_.Get();
}
inline void ResponseAddAccount::_internal_set_err_string(const std::string& value) {
  
  err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseAddAccount::_internal_mutable_err_string() {
  
  return err_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseAddAccount::release_err_string() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.ResponseAddAccount.err_string)
  return err_string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseAddAccount::set_allocated_err_string(std::string* err_string) {
  if (err_string != nullptr) {
    
  } else {
    
  }
  err_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), err_string,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (err_string_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    err_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.ResponseAddAccount.err_string)
}

// int64 user_id = 4;
inline void ResponseAddAccount::clear_user_id() {
  user_id_ = int64_t{0};
}
inline int64_t ResponseAddAccount::_internal_user_id() const {
  return user_id_;
}
inline int64_t ResponseAddAccount::user_id() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseAddAccount.user_id)
  return _internal_user_id();
}
inline void ResponseAddAccount::_internal_set_user_id(int64_t value) {
  
  user_id_ = value;
}
inline void ResponseAddAccount::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseAddAccount.user_id)
}

// -------------------------------------------------------------------

// RequestEnableAccount

// int64 seq = 1;
inline void RequestEnableAccount::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t RequestEnableAccount::_internal_seq() const {
  return seq_;
}
inline int64_t RequestEnableAccount::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestEnableAccount.seq)
  return _internal_seq();
}
inline void RequestEnableAccount::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void RequestEnableAccount::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestEnableAccount.seq)
}

// string account = 2;
inline void RequestEnableAccount::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& RequestEnableAccount::account() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestEnableAccount.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestEnableAccount::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestEnableAccount.account)
}
inline std::string* RequestEnableAccount::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.RequestEnableAccount.account)
  return _s;
}
inline const std::string& RequestEnableAccount::_internal_account() const {
  return account_.Get();
}
inline void RequestEnableAccount::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestEnableAccount::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestEnableAccount::release_account() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.RequestEnableAccount.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestEnableAccount::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.RequestEnableAccount.account)
}

// -------------------------------------------------------------------

// ResponseEnableAccount

// int64 seq = 1;
inline void ResponseEnableAccount::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t ResponseEnableAccount::_internal_seq() const {
  return seq_;
}
inline int64_t ResponseEnableAccount::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseEnableAccount.seq)
  return _internal_seq();
}
inline void ResponseEnableAccount::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void ResponseEnableAccount::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseEnableAccount.seq)
}

// int32 err_code = 2;
inline void ResponseEnableAccount::clear_err_code() {
  err_code_ = 0;
}
inline int32_t ResponseEnableAccount::_internal_err_code() const {
  return err_code_;
}
inline int32_t ResponseEnableAccount::err_code() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseEnableAccount.err_code)
  return _internal_err_code();
}
inline void ResponseEnableAccount::_internal_set_err_code(int32_t value) {
  
  err_code_ = value;
}
inline void ResponseEnableAccount::set_err_code(int32_t value) {
  _internal_set_err_code(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseEnableAccount.err_code)
}

// string err_string = 3;
inline void ResponseEnableAccount::clear_err_string() {
  err_string_.ClearToEmpty();
}
inline const std::string& ResponseEnableAccount::err_string() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseEnableAccount.err_string)
  return _internal_err_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseEnableAccount::set_err_string(ArgT0&& arg0, ArgT... args) {
 
 err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseEnableAccount.err_string)
}
inline std::string* ResponseEnableAccount::mutable_err_string() {
  std::string* _s = _internal_mutable_err_string();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.ResponseEnableAccount.err_string)
  return _s;
}
inline const std::string& ResponseEnableAccount::_internal_err_string() const {
  return err_string_.Get();
}
inline void ResponseEnableAccount::_internal_set_err_string(const std::string& value) {
  
  err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseEnableAccount::_internal_mutable_err_string() {
  
  return err_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseEnableAccount::release_err_string() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.ResponseEnableAccount.err_string)
  return err_string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseEnableAccount::set_allocated_err_string(std::string* err_string) {
  if (err_string != nullptr) {
    
  } else {
    
  }
  err_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), err_string,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (err_string_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    err_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.ResponseEnableAccount.err_string)
}

// -------------------------------------------------------------------

// RequestDisableAccount

// int64 seq = 1;
inline void RequestDisableAccount::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t RequestDisableAccount::_internal_seq() const {
  return seq_;
}
inline int64_t RequestDisableAccount::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestDisableAccount.seq)
  return _internal_seq();
}
inline void RequestDisableAccount::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void RequestDisableAccount::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestDisableAccount.seq)
}

// string account = 2;
inline void RequestDisableAccount::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& RequestDisableAccount::account() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestDisableAccount.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestDisableAccount::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestDisableAccount.account)
}
inline std::string* RequestDisableAccount::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.RequestDisableAccount.account)
  return _s;
}
inline const std::string& RequestDisableAccount::_internal_account() const {
  return account_.Get();
}
inline void RequestDisableAccount::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestDisableAccount::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestDisableAccount::release_account() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.RequestDisableAccount.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestDisableAccount::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.RequestDisableAccount.account)
}

// -------------------------------------------------------------------

// ResponseDisableAccount

// int64 seq = 1;
inline void ResponseDisableAccount::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t ResponseDisableAccount::_internal_seq() const {
  return seq_;
}
inline int64_t ResponseDisableAccount::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseDisableAccount.seq)
  return _internal_seq();
}
inline void ResponseDisableAccount::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void ResponseDisableAccount::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseDisableAccount.seq)
}

// int32 err_code = 2;
inline void ResponseDisableAccount::clear_err_code() {
  err_code_ = 0;
}
inline int32_t ResponseDisableAccount::_internal_err_code() const {
  return err_code_;
}
inline int32_t ResponseDisableAccount::err_code() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseDisableAccount.err_code)
  return _internal_err_code();
}
inline void ResponseDisableAccount::_internal_set_err_code(int32_t value) {
  
  err_code_ = value;
}
inline void ResponseDisableAccount::set_err_code(int32_t value) {
  _internal_set_err_code(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseDisableAccount.err_code)
}

// string err_string = 3;
inline void ResponseDisableAccount::clear_err_string() {
  err_string_.ClearToEmpty();
}
inline const std::string& ResponseDisableAccount::err_string() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseDisableAccount.err_string)
  return _internal_err_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseDisableAccount::set_err_string(ArgT0&& arg0, ArgT... args) {
 
 err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseDisableAccount.err_string)
}
inline std::string* ResponseDisableAccount::mutable_err_string() {
  std::string* _s = _internal_mutable_err_string();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.ResponseDisableAccount.err_string)
  return _s;
}
inline const std::string& ResponseDisableAccount::_internal_err_string() const {
  return err_string_.Get();
}
inline void ResponseDisableAccount::_internal_set_err_string(const std::string& value) {
  
  err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseDisableAccount::_internal_mutable_err_string() {
  
  return err_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseDisableAccount::release_err_string() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.ResponseDisableAccount.err_string)
  return err_string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseDisableAccount::set_allocated_err_string(std::string* err_string) {
  if (err_string != nullptr) {
    
  } else {
    
  }
  err_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), err_string,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (err_string_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    err_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.ResponseDisableAccount.err_string)
}

// -------------------------------------------------------------------

// RequestDeleteAccount

// int64 seq = 1;
inline void RequestDeleteAccount::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t RequestDeleteAccount::_internal_seq() const {
  return seq_;
}
inline int64_t RequestDeleteAccount::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestDeleteAccount.seq)
  return _internal_seq();
}
inline void RequestDeleteAccount::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void RequestDeleteAccount::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestDeleteAccount.seq)
}

// string account = 2;
inline void RequestDeleteAccount::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& RequestDeleteAccount::account() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestDeleteAccount.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestDeleteAccount::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestDeleteAccount.account)
}
inline std::string* RequestDeleteAccount::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.RequestDeleteAccount.account)
  return _s;
}
inline const std::string& RequestDeleteAccount::_internal_account() const {
  return account_.Get();
}
inline void RequestDeleteAccount::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestDeleteAccount::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestDeleteAccount::release_account() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.RequestDeleteAccount.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestDeleteAccount::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.RequestDeleteAccount.account)
}

// -------------------------------------------------------------------

// ResponseDeleteAccount

// int64 seq = 1;
inline void ResponseDeleteAccount::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t ResponseDeleteAccount::_internal_seq() const {
  return seq_;
}
inline int64_t ResponseDeleteAccount::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseDeleteAccount.seq)
  return _internal_seq();
}
inline void ResponseDeleteAccount::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void ResponseDeleteAccount::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseDeleteAccount.seq)
}

// int32 err_code = 2;
inline void ResponseDeleteAccount::clear_err_code() {
  err_code_ = 0;
}
inline int32_t ResponseDeleteAccount::_internal_err_code() const {
  return err_code_;
}
inline int32_t ResponseDeleteAccount::err_code() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseDeleteAccount.err_code)
  return _internal_err_code();
}
inline void ResponseDeleteAccount::_internal_set_err_code(int32_t value) {
  
  err_code_ = value;
}
inline void ResponseDeleteAccount::set_err_code(int32_t value) {
  _internal_set_err_code(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseDeleteAccount.err_code)
}

// string err_string = 3;
inline void ResponseDeleteAccount::clear_err_string() {
  err_string_.ClearToEmpty();
}
inline const std::string& ResponseDeleteAccount::err_string() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseDeleteAccount.err_string)
  return _internal_err_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseDeleteAccount::set_err_string(ArgT0&& arg0, ArgT... args) {
 
 err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseDeleteAccount.err_string)
}
inline std::string* ResponseDeleteAccount::mutable_err_string() {
  std::string* _s = _internal_mutable_err_string();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.ResponseDeleteAccount.err_string)
  return _s;
}
inline const std::string& ResponseDeleteAccount::_internal_err_string() const {
  return err_string_.Get();
}
inline void ResponseDeleteAccount::_internal_set_err_string(const std::string& value) {
  
  err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseDeleteAccount::_internal_mutable_err_string() {
  
  return err_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseDeleteAccount::release_err_string() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.ResponseDeleteAccount.err_string)
  return err_string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseDeleteAccount::set_allocated_err_string(std::string* err_string) {
  if (err_string != nullptr) {
    
  } else {
    
  }
  err_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), err_string,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (err_string_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    err_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.ResponseDeleteAccount.err_string)
}

// -------------------------------------------------------------------

// RequestChangeAccountPassword

// int64 seq = 1;
inline void RequestChangeAccountPassword::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t RequestChangeAccountPassword::_internal_seq() const {
  return seq_;
}
inline int64_t RequestChangeAccountPassword::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestChangeAccountPassword.seq)
  return _internal_seq();
}
inline void RequestChangeAccountPassword::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void RequestChangeAccountPassword::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestChangeAccountPassword.seq)
}

// string account = 2;
inline void RequestChangeAccountPassword::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& RequestChangeAccountPassword::account() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestChangeAccountPassword.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestChangeAccountPassword::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestChangeAccountPassword.account)
}
inline std::string* RequestChangeAccountPassword::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.RequestChangeAccountPassword.account)
  return _s;
}
inline const std::string& RequestChangeAccountPassword::_internal_account() const {
  return account_.Get();
}
inline void RequestChangeAccountPassword::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestChangeAccountPassword::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestChangeAccountPassword::release_account() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.RequestChangeAccountPassword.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestChangeAccountPassword::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.RequestChangeAccountPassword.account)
}

// string password = 3;
inline void RequestChangeAccountPassword::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& RequestChangeAccountPassword::password() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestChangeAccountPassword.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestChangeAccountPassword::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestChangeAccountPassword.password)
}
inline std::string* RequestChangeAccountPassword::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.RequestChangeAccountPassword.password)
  return _s;
}
inline const std::string& RequestChangeAccountPassword::_internal_password() const {
  return password_.Get();
}
inline void RequestChangeAccountPassword::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestChangeAccountPassword::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestChangeAccountPassword::release_password() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.RequestChangeAccountPassword.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestChangeAccountPassword::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.RequestChangeAccountPassword.password)
}

// -------------------------------------------------------------------

// ResponseChangeAccountPassword

// int64 seq = 1;
inline void ResponseChangeAccountPassword::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t ResponseChangeAccountPassword::_internal_seq() const {
  return seq_;
}
inline int64_t ResponseChangeAccountPassword::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseChangeAccountPassword.seq)
  return _internal_seq();
}
inline void ResponseChangeAccountPassword::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void ResponseChangeAccountPassword::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseChangeAccountPassword.seq)
}

// int32 err_code = 2;
inline void ResponseChangeAccountPassword::clear_err_code() {
  err_code_ = 0;
}
inline int32_t ResponseChangeAccountPassword::_internal_err_code() const {
  return err_code_;
}
inline int32_t ResponseChangeAccountPassword::err_code() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseChangeAccountPassword.err_code)
  return _internal_err_code();
}
inline void ResponseChangeAccountPassword::_internal_set_err_code(int32_t value) {
  
  err_code_ = value;
}
inline void ResponseChangeAccountPassword::set_err_code(int32_t value) {
  _internal_set_err_code(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseChangeAccountPassword.err_code)
}

// string err_string = 3;
inline void ResponseChangeAccountPassword::clear_err_string() {
  err_string_.ClearToEmpty();
}
inline const std::string& ResponseChangeAccountPassword::err_string() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseChangeAccountPassword.err_string)
  return _internal_err_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseChangeAccountPassword::set_err_string(ArgT0&& arg0, ArgT... args) {
 
 err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseChangeAccountPassword.err_string)
}
inline std::string* ResponseChangeAccountPassword::mutable_err_string() {
  std::string* _s = _internal_mutable_err_string();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.ResponseChangeAccountPassword.err_string)
  return _s;
}
inline const std::string& ResponseChangeAccountPassword::_internal_err_string() const {
  return err_string_.Get();
}
inline void ResponseChangeAccountPassword::_internal_set_err_string(const std::string& value) {
  
  err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseChangeAccountPassword::_internal_mutable_err_string() {
  
  return err_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseChangeAccountPassword::release_err_string() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.ResponseChangeAccountPassword.err_string)
  return err_string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseChangeAccountPassword::set_allocated_err_string(std::string* err_string) {
  if (err_string != nullptr) {
    
  } else {
    
  }
  err_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), err_string,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (err_string_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    err_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.ResponseChangeAccountPassword.err_string)
}

// -------------------------------------------------------------------

// RequestListBlockedIPAddresses

// int64 seq = 1;
inline void RequestListBlockedIPAddresses::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t RequestListBlockedIPAddresses::_internal_seq() const {
  return seq_;
}
inline int64_t RequestListBlockedIPAddresses::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestListBlockedIPAddresses.seq)
  return _internal_seq();
}
inline void RequestListBlockedIPAddresses::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void RequestListBlockedIPAddresses::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestListBlockedIPAddresses.seq)
}

// -------------------------------------------------------------------

// BlockedIPAddress

// string ip_address = 1;
inline void BlockedIPAddress::clear_ip_address() {
  ip_address_.ClearToEmpty();
}
inline const std::string& BlockedIPAddress::ip_address() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.BlockedIPAddress.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockedIPAddress::set_ip_address(ArgT0&& arg0, ArgT... args) {
 
 ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.BlockedIPAddress.ip_address)
}
inline std::string* BlockedIPAddress::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.BlockedIPAddress.ip_address)
  return _s;
}
inline const std::string& BlockedIPAddress::_internal_ip_address() const {
  return ip_address_.Get();
}
inline void BlockedIPAddress::_internal_set_ip_address(const std::string& value) {
  
  ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockedIPAddress::_internal_mutable_ip_address() {
  
  return ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockedIPAddress::release_ip_address() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.BlockedIPAddress.ip_address)
  return ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockedIPAddress::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    
  } else {
    
  }
  ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.BlockedIPAddress.ip_address)
}

// int64 until = 2;
inline void BlockedIPAddress::clear_until() {
  until_ = int64_t{0};
}
inline int64_t BlockedIPAddress::_internal_until() const {
  return until_;
}
inline int64_t BlockedIPAddress::until() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.BlockedIPAddress.until)
  return _internal_until();
}
inline void BlockedIPAddress::_internal_set_until(int64_t value) {
  
  until_ = value;
}
inline void BlockedIPAddress::set_until(int64_t value) {
  _internal_set_until(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.BlockedIPAddress.until)
}

// -------------------------------------------------------------------

// ResponseListBlockedIPAddresses

// int64 seq = 1;
inline void ResponseListBlockedIPAddresses::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t ResponseListBlockedIPAddresses::_internal_seq() const {
  return seq_;
}
inline int64_t ResponseListBlockedIPAddresses::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseListBlockedIPAddresses.seq)
  return _internal_seq();
}
inline void ResponseListBlockedIPAddresses::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void ResponseListBlockedIPAddresses::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseListBlockedIPAddresses.seq)
}

// int32 err_code = 2;
inline void ResponseListBlockedIPAddresses::clear_err_code() {
  err_code_ = 0;
}
inline int32_t ResponseListBlockedIPAddresses::_internal_err_code() const {
  return err_code_;
}
inline int32_t ResponseListBlockedIPAddresses::err_code() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseListBlockedIPAddresses.err_code)
  return _internal_err_code();
}
inline void ResponseListBlockedIPAddresses::_internal_set_err_code(int32_t value) {
  
  err_code_ = value;
}
inline void ResponseListBlockedIPAddresses::set_err_code(int32_t value) {
  _internal_set_err_code(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseListBlockedIPAddresses.err_code)
}

// string err_string = 3;
inline void ResponseListBlockedIPAddresses::clear_err_string() {
  err_string_.ClearToEmpty();
}
inline const std::string& ResponseListBlockedIPAddresses::err_string() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseListBlockedIPAddresses.err_string)
  return _internal_err_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseListBlockedIPAddresses::set_err_string(ArgT0&& arg0, ArgT... args) {
 
 err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseListBlockedIPAddresses.err_string)
}
inline std::string* ResponseListBlockedIPAddresses::mutable_err_string() {
  std::string* _s = _internal_mutable_err_string();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.ResponseListBlockedIPAddresses.err_string)
  return _s;
}
inline const std::string& ResponseListBlockedIPAddresses::_internal_err_string() const {
  return err_string_.Get();
}
inline void ResponseListBlockedIPAddresses::_internal_set_err_string(const std::string& value) {
  
  err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseListBlockedIPAddresses::_internal_mutable_err_string() {
  
  return err_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseListBlockedIPAddresses::release_err_string() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.ResponseListBlockedIPAddresses.err_string)
  return err_string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseListBlockedIPAddresses::set_allocated_err_string(std::string* err_string) {
  if (err_string != nullptr) {
    
  } else {
    
  }
  err_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), err_string,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (err_string_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    err_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.ResponseListBlockedIPAddresses.err_string)
}

// repeated .Global.Protocol.Server.Management.BlockedIPAddress ip_addresses = 4;
inline int ResponseListBlockedIPAddresses::_internal_ip_addresses_size() const {
  return ip_addresses_.size();
}
inline int ResponseListBlockedIPAddresses::ip_addresses_size() const {
  return _internal_ip_addresses_size();
}
inline void ResponseListBlockedIPAddresses::clear_ip_addresses() {
  ip_addresses_.Clear();
}
inline ::Global::Protocol::Server::Management::BlockedIPAddress* ResponseListBlockedIPAddresses::mutable_ip_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.ResponseListBlockedIPAddresses.ip_addresses)
  return ip_addresses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Global::Protocol::Server::Management::BlockedIPAddress >*
ResponseListBlockedIPAddresses::mutable_ip_addresses() {
  // @@protoc_insertion_point(field_mutable_list:Global.Protocol.Server.Management.ResponseListBlockedIPAddresses.ip_addresses)
  return &ip_addresses_;
}
inline const ::Global::Protocol::Server::Management::BlockedIPAddress& ResponseListBlockedIPAddresses::_internal_ip_addresses(int index) const {
  return ip_addresses_.Get(index);
}
inline const ::Global::Protocol::Server::Management::BlockedIPAddress& ResponseListBlockedIPAddresses::ip_addresses(int index) const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseListBlockedIPAddresses.ip_addresses)
  return _internal_ip_addresses(index);
}
inline ::Global::Protocol::Server::Management::BlockedIPAddress* ResponseListBlockedIPAddresses::_internal_add_ip_addresses() {
  return ip_addresses_.Add();
}
inline ::Global::Protocol::Server::Management::BlockedIPAddress* ResponseListBlockedIPAddresses::add_ip_addresses() {
  ::Global::Protocol::Server::Management::BlockedIPAddress* _add = _internal_add_ip_addresses();
  // @@protoc_insertion_point(field_add:Global.Protocol.Server.Management.ResponseListBlockedIPAddresses.ip_addresses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Global::Protocol::Server::Management::BlockedIPAddress >&
ResponseListBlockedIPAddresses::ip_addresses() const {
  // @@protoc_insertion_point(field_list:Global.Protocol.Server.Management.ResponseListBlockedIPAddresses.ip_addresses)
  return ip_addresses_;
}

// -------------------------------------------------------------------

// RequestRemoveBlockedIPAddress

// int64 seq = 1;
inline void RequestRemoveBlockedIPAddress::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t RequestRemoveBlockedIPAddress::_internal_seq() const {
  return seq_;
}
inline int64_t RequestRemoveBlockedIPAddress::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestRemoveBlockedIPAddress.seq)
  return _internal_seq();
}
inline void RequestRemoveBlockedIPAddress::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void RequestRemoveBlockedIPAddress::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestRemoveBlockedIPAddress.seq)
}

// string ip_address = 2;
inline void RequestRemoveBlockedIPAddress::clear_ip_address() {
  ip_address_.ClearToEmpty();
}
inline const std::string& RequestRemoveBlockedIPAddress::ip_address() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestRemoveBlockedIPAddress.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestRemoveBlockedIPAddress::set_ip_address(ArgT0&& arg0, ArgT... args) {
 
 ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestRemoveBlockedIPAddress.ip_address)
}
inline std::string* RequestRemoveBlockedIPAddress::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.RequestRemoveBlockedIPAddress.ip_address)
  return _s;
}
inline const std::string& RequestRemoveBlockedIPAddress::_internal_ip_address() const {
  return ip_address_.Get();
}
inline void RequestRemoveBlockedIPAddress::_internal_set_ip_address(const std::string& value) {
  
  ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestRemoveBlockedIPAddress::_internal_mutable_ip_address() {
  
  return ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestRemoveBlockedIPAddress::release_ip_address() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.RequestRemoveBlockedIPAddress.ip_address)
  return ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestRemoveBlockedIPAddress::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    
  } else {
    
  }
  ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.RequestRemoveBlockedIPAddress.ip_address)
}

// -------------------------------------------------------------------

// ResponseRemoveBlockedIPAddress

// int64 seq = 1;
inline void ResponseRemoveBlockedIPAddress::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t ResponseRemoveBlockedIPAddress::_internal_seq() const {
  return seq_;
}
inline int64_t ResponseRemoveBlockedIPAddress::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseRemoveBlockedIPAddress.seq)
  return _internal_seq();
}
inline void ResponseRemoveBlockedIPAddress::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void ResponseRemoveBlockedIPAddress::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseRemoveBlockedIPAddress.seq)
}

// int32 err_code = 2;
inline void ResponseRemoveBlockedIPAddress::clear_err_code() {
  err_code_ = 0;
}
inline int32_t ResponseRemoveBlockedIPAddress::_internal_err_code() const {
  return err_code_;
}
inline int32_t ResponseRemoveBlockedIPAddress::err_code() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseRemoveBlockedIPAddress.err_code)
  return _internal_err_code();
}
inline void ResponseRemoveBlockedIPAddress::_internal_set_err_code(int32_t value) {
  
  err_code_ = value;
}
inline void ResponseRemoveBlockedIPAddress::set_err_code(int32_t value) {
  _internal_set_err_code(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseRemoveBlockedIPAddress.err_code)
}

// string err_string = 3;
inline void ResponseRemoveBlockedIPAddress::clear_err_string() {
  err_string_.ClearToEmpty();
}
inline const std::string& ResponseRemoveBlockedIPAddress::err_string() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseRemoveBlockedIPAddress.err_string)
  return _internal_err_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseRemoveBlockedIPAddress::set_err_string(ArgT0&& arg0, ArgT... args) {
 
 err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseRemoveBlockedIPAddress.err_string)
}
inline std::string* ResponseRemoveBlockedIPAddress::mutable_err_string() {
  std::string* _s = _internal_mutable_err_string();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.ResponseRemoveBlockedIPAddress.err_string)
  return _s;
}
inline const std::string& ResponseRemoveBlockedIPAddress::_internal_err_string() const {
  return err_string_.Get();
}
inline void ResponseRemoveBlockedIPAddress::_internal_set_err_string(const std::string& value) {
  
  err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseRemoveBlockedIPAddress::_internal_mutable_err_string() {
  
  return err_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseRemoveBlockedIPAddress::release_err_string() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.ResponseRemoveBlockedIPAddress.err_string)
  return err_string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseRemoveBlockedIPAddress::set_allocated_err_string(std::string* err_string) {
  if (err_string != nullptr) {
    
  } else {
    
  }
  err_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), err_string,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (err_string_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    err_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.ResponseRemoveBlockedIPAddress.err_string)
}

// -------------------------------------------------------------------

// RequestAddBlockedIPAddress

// int64 seq = 1;
inline void RequestAddBlockedIPAddress::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t RequestAddBlockedIPAddress::_internal_seq() const {
  return seq_;
}
inline int64_t RequestAddBlockedIPAddress::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestAddBlockedIPAddress.seq)
  return _internal_seq();
}
inline void RequestAddBlockedIPAddress::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void RequestAddBlockedIPAddress::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestAddBlockedIPAddress.seq)
}

// string ip_address = 2;
inline void RequestAddBlockedIPAddress::clear_ip_address() {
  ip_address_.ClearToEmpty();
}
inline const std::string& RequestAddBlockedIPAddress::ip_address() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestAddBlockedIPAddress.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestAddBlockedIPAddress::set_ip_address(ArgT0&& arg0, ArgT... args) {
 
 ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestAddBlockedIPAddress.ip_address)
}
inline std::string* RequestAddBlockedIPAddress::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.RequestAddBlockedIPAddress.ip_address)
  return _s;
}
inline const std::string& RequestAddBlockedIPAddress::_internal_ip_address() const {
  return ip_address_.Get();
}
inline void RequestAddBlockedIPAddress::_internal_set_ip_address(const std::string& value) {
  
  ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestAddBlockedIPAddress::_internal_mutable_ip_address() {
  
  return ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestAddBlockedIPAddress::release_ip_address() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.RequestAddBlockedIPAddress.ip_address)
  return ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestAddBlockedIPAddress::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    
  } else {
    
  }
  ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.RequestAddBlockedIPAddress.ip_address)
}

// int32 duration = 3;
inline void RequestAddBlockedIPAddress::clear_duration() {
  duration_ = 0;
}
inline int32_t RequestAddBlockedIPAddress::_internal_duration() const {
  return duration_;
}
inline int32_t RequestAddBlockedIPAddress::duration() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestAddBlockedIPAddress.duration)
  return _internal_duration();
}
inline void RequestAddBlockedIPAddress::_internal_set_duration(int32_t value) {
  
  duration_ = value;
}
inline void RequestAddBlockedIPAddress::set_duration(int32_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestAddBlockedIPAddress.duration)
}

// -------------------------------------------------------------------

// ResponseAddBlockedIPAddress

// int64 seq = 1;
inline void ResponseAddBlockedIPAddress::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t ResponseAddBlockedIPAddress::_internal_seq() const {
  return seq_;
}
inline int64_t ResponseAddBlockedIPAddress::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseAddBlockedIPAddress.seq)
  return _internal_seq();
}
inline void ResponseAddBlockedIPAddress::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void ResponseAddBlockedIPAddress::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseAddBlockedIPAddress.seq)
}

// int32 err_code = 2;
inline void ResponseAddBlockedIPAddress::clear_err_code() {
  err_code_ = 0;
}
inline int32_t ResponseAddBlockedIPAddress::_internal_err_code() const {
  return err_code_;
}
inline int32_t ResponseAddBlockedIPAddress::err_code() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseAddBlockedIPAddress.err_code)
  return _internal_err_code();
}
inline void ResponseAddBlockedIPAddress::_internal_set_err_code(int32_t value) {
  
  err_code_ = value;
}
inline void ResponseAddBlockedIPAddress::set_err_code(int32_t value) {
  _internal_set_err_code(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseAddBlockedIPAddress.err_code)
}

// string err_string = 3;
inline void ResponseAddBlockedIPAddress::clear_err_string() {
  err_string_.ClearToEmpty();
}
inline const std::string& ResponseAddBlockedIPAddress::err_string() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseAddBlockedIPAddress.err_string)
  return _internal_err_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseAddBlockedIPAddress::set_err_string(ArgT0&& arg0, ArgT... args) {
 
 err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseAddBlockedIPAddress.err_string)
}
inline std::string* ResponseAddBlockedIPAddress::mutable_err_string() {
  std::string* _s = _internal_mutable_err_string();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.ResponseAddBlockedIPAddress.err_string)
  return _s;
}
inline const std::string& ResponseAddBlockedIPAddress::_internal_err_string() const {
  return err_string_.Get();
}
inline void ResponseAddBlockedIPAddress::_internal_set_err_string(const std::string& value) {
  
  err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseAddBlockedIPAddress::_internal_mutable_err_string() {
  
  return err_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseAddBlockedIPAddress::release_err_string() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.ResponseAddBlockedIPAddress.err_string)
  return err_string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseAddBlockedIPAddress::set_allocated_err_string(std::string* err_string) {
  if (err_string != nullptr) {
    
  } else {
    
  }
  err_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), err_string,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (err_string_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    err_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.ResponseAddBlockedIPAddress.err_string)
}

// -------------------------------------------------------------------

// RequestListBlockedAccounts

// int64 seq = 1;
inline void RequestListBlockedAccounts::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t RequestListBlockedAccounts::_internal_seq() const {
  return seq_;
}
inline int64_t RequestListBlockedAccounts::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestListBlockedAccounts.seq)
  return _internal_seq();
}
inline void RequestListBlockedAccounts::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void RequestListBlockedAccounts::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestListBlockedAccounts.seq)
}

// -------------------------------------------------------------------

// BlockedAccount

// int64 user_id = 1;
inline void BlockedAccount::clear_user_id() {
  user_id_ = int64_t{0};
}
inline int64_t BlockedAccount::_internal_user_id() const {
  return user_id_;
}
inline int64_t BlockedAccount::user_id() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.BlockedAccount.user_id)
  return _internal_user_id();
}
inline void BlockedAccount::_internal_set_user_id(int64_t value) {
  
  user_id_ = value;
}
inline void BlockedAccount::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.BlockedAccount.user_id)
}

// string account = 2;
inline void BlockedAccount::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& BlockedAccount::account() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.BlockedAccount.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockedAccount::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.BlockedAccount.account)
}
inline std::string* BlockedAccount::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.BlockedAccount.account)
  return _s;
}
inline const std::string& BlockedAccount::_internal_account() const {
  return account_.Get();
}
inline void BlockedAccount::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockedAccount::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockedAccount::release_account() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.BlockedAccount.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockedAccount::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.BlockedAccount.account)
}

// int64 until = 3;
inline void BlockedAccount::clear_until() {
  until_ = int64_t{0};
}
inline int64_t BlockedAccount::_internal_until() const {
  return until_;
}
inline int64_t BlockedAccount::until() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.BlockedAccount.until)
  return _internal_until();
}
inline void BlockedAccount::_internal_set_until(int64_t value) {
  
  until_ = value;
}
inline void BlockedAccount::set_until(int64_t value) {
  _internal_set_until(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.BlockedAccount.until)
}

// -------------------------------------------------------------------

// ResponseListBlockedAccounts

// int64 seq = 1;
inline void ResponseListBlockedAccounts::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t ResponseListBlockedAccounts::_internal_seq() const {
  return seq_;
}
inline int64_t ResponseListBlockedAccounts::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseListBlockedAccounts.seq)
  return _internal_seq();
}
inline void ResponseListBlockedAccounts::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void ResponseListBlockedAccounts::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseListBlockedAccounts.seq)
}

// int32 err_code = 2;
inline void ResponseListBlockedAccounts::clear_err_code() {
  err_code_ = 0;
}
inline int32_t ResponseListBlockedAccounts::_internal_err_code() const {
  return err_code_;
}
inline int32_t ResponseListBlockedAccounts::err_code() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseListBlockedAccounts.err_code)
  return _internal_err_code();
}
inline void ResponseListBlockedAccounts::_internal_set_err_code(int32_t value) {
  
  err_code_ = value;
}
inline void ResponseListBlockedAccounts::set_err_code(int32_t value) {
  _internal_set_err_code(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseListBlockedAccounts.err_code)
}

// string err_string = 3;
inline void ResponseListBlockedAccounts::clear_err_string() {
  err_string_.ClearToEmpty();
}
inline const std::string& ResponseListBlockedAccounts::err_string() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseListBlockedAccounts.err_string)
  return _internal_err_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseListBlockedAccounts::set_err_string(ArgT0&& arg0, ArgT... args) {
 
 err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseListBlockedAccounts.err_string)
}
inline std::string* ResponseListBlockedAccounts::mutable_err_string() {
  std::string* _s = _internal_mutable_err_string();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.ResponseListBlockedAccounts.err_string)
  return _s;
}
inline const std::string& ResponseListBlockedAccounts::_internal_err_string() const {
  return err_string_.Get();
}
inline void ResponseListBlockedAccounts::_internal_set_err_string(const std::string& value) {
  
  err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseListBlockedAccounts::_internal_mutable_err_string() {
  
  return err_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseListBlockedAccounts::release_err_string() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.ResponseListBlockedAccounts.err_string)
  return err_string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseListBlockedAccounts::set_allocated_err_string(std::string* err_string) {
  if (err_string != nullptr) {
    
  } else {
    
  }
  err_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), err_string,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (err_string_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    err_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.ResponseListBlockedAccounts.err_string)
}

// repeated .Global.Protocol.Server.Management.BlockedAccount accounts = 4;
inline int ResponseListBlockedAccounts::_internal_accounts_size() const {
  return accounts_.size();
}
inline int ResponseListBlockedAccounts::accounts_size() const {
  return _internal_accounts_size();
}
inline void ResponseListBlockedAccounts::clear_accounts() {
  accounts_.Clear();
}
inline ::Global::Protocol::Server::Management::BlockedAccount* ResponseListBlockedAccounts::mutable_accounts(int index) {
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.ResponseListBlockedAccounts.accounts)
  return accounts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Global::Protocol::Server::Management::BlockedAccount >*
ResponseListBlockedAccounts::mutable_accounts() {
  // @@protoc_insertion_point(field_mutable_list:Global.Protocol.Server.Management.ResponseListBlockedAccounts.accounts)
  return &accounts_;
}
inline const ::Global::Protocol::Server::Management::BlockedAccount& ResponseListBlockedAccounts::_internal_accounts(int index) const {
  return accounts_.Get(index);
}
inline const ::Global::Protocol::Server::Management::BlockedAccount& ResponseListBlockedAccounts::accounts(int index) const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseListBlockedAccounts.accounts)
  return _internal_accounts(index);
}
inline ::Global::Protocol::Server::Management::BlockedAccount* ResponseListBlockedAccounts::_internal_add_accounts() {
  return accounts_.Add();
}
inline ::Global::Protocol::Server::Management::BlockedAccount* ResponseListBlockedAccounts::add_accounts() {
  ::Global::Protocol::Server::Management::BlockedAccount* _add = _internal_add_accounts();
  // @@protoc_insertion_point(field_add:Global.Protocol.Server.Management.ResponseListBlockedAccounts.accounts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Global::Protocol::Server::Management::BlockedAccount >&
ResponseListBlockedAccounts::accounts() const {
  // @@protoc_insertion_point(field_list:Global.Protocol.Server.Management.ResponseListBlockedAccounts.accounts)
  return accounts_;
}

// -------------------------------------------------------------------

// RequestRemoveBlockedAccount

// int64 seq = 1;
inline void RequestRemoveBlockedAccount::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t RequestRemoveBlockedAccount::_internal_seq() const {
  return seq_;
}
inline int64_t RequestRemoveBlockedAccount::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestRemoveBlockedAccount.seq)
  return _internal_seq();
}
inline void RequestRemoveBlockedAccount::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void RequestRemoveBlockedAccount::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestRemoveBlockedAccount.seq)
}

// int64 user_id = 2;
inline void RequestRemoveBlockedAccount::clear_user_id() {
  user_id_ = int64_t{0};
}
inline int64_t RequestRemoveBlockedAccount::_internal_user_id() const {
  return user_id_;
}
inline int64_t RequestRemoveBlockedAccount::user_id() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestRemoveBlockedAccount.user_id)
  return _internal_user_id();
}
inline void RequestRemoveBlockedAccount::_internal_set_user_id(int64_t value) {
  
  user_id_ = value;
}
inline void RequestRemoveBlockedAccount::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestRemoveBlockedAccount.user_id)
}

// -------------------------------------------------------------------

// ResponseRemoveBlockedAccount

// int64 seq = 1;
inline void ResponseRemoveBlockedAccount::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t ResponseRemoveBlockedAccount::_internal_seq() const {
  return seq_;
}
inline int64_t ResponseRemoveBlockedAccount::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseRemoveBlockedAccount.seq)
  return _internal_seq();
}
inline void ResponseRemoveBlockedAccount::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void ResponseRemoveBlockedAccount::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseRemoveBlockedAccount.seq)
}

// int32 err_code = 2;
inline void ResponseRemoveBlockedAccount::clear_err_code() {
  err_code_ = 0;
}
inline int32_t ResponseRemoveBlockedAccount::_internal_err_code() const {
  return err_code_;
}
inline int32_t ResponseRemoveBlockedAccount::err_code() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseRemoveBlockedAccount.err_code)
  return _internal_err_code();
}
inline void ResponseRemoveBlockedAccount::_internal_set_err_code(int32_t value) {
  
  err_code_ = value;
}
inline void ResponseRemoveBlockedAccount::set_err_code(int32_t value) {
  _internal_set_err_code(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseRemoveBlockedAccount.err_code)
}

// string err_string = 3;
inline void ResponseRemoveBlockedAccount::clear_err_string() {
  err_string_.ClearToEmpty();
}
inline const std::string& ResponseRemoveBlockedAccount::err_string() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseRemoveBlockedAccount.err_string)
  return _internal_err_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseRemoveBlockedAccount::set_err_string(ArgT0&& arg0, ArgT... args) {
 
 err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseRemoveBlockedAccount.err_string)
}
inline std::string* ResponseRemoveBlockedAccount::mutable_err_string() {
  std::string* _s = _internal_mutable_err_string();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.ResponseRemoveBlockedAccount.err_string)
  return _s;
}
inline const std::string& ResponseRemoveBlockedAccount::_internal_err_string() const {
  return err_string_.Get();
}
inline void ResponseRemoveBlockedAccount::_internal_set_err_string(const std::string& value) {
  
  err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseRemoveBlockedAccount::_internal_mutable_err_string() {
  
  return err_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseRemoveBlockedAccount::release_err_string() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.ResponseRemoveBlockedAccount.err_string)
  return err_string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseRemoveBlockedAccount::set_allocated_err_string(std::string* err_string) {
  if (err_string != nullptr) {
    
  } else {
    
  }
  err_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), err_string,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (err_string_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    err_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.ResponseRemoveBlockedAccount.err_string)
}

// -------------------------------------------------------------------

// RequestAddBlockedAccount

// int64 seq = 1;
inline void RequestAddBlockedAccount::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t RequestAddBlockedAccount::_internal_seq() const {
  return seq_;
}
inline int64_t RequestAddBlockedAccount::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestAddBlockedAccount.seq)
  return _internal_seq();
}
inline void RequestAddBlockedAccount::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void RequestAddBlockedAccount::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestAddBlockedAccount.seq)
}

// int64 user_id = 2;
inline void RequestAddBlockedAccount::clear_user_id() {
  user_id_ = int64_t{0};
}
inline int64_t RequestAddBlockedAccount::_internal_user_id() const {
  return user_id_;
}
inline int64_t RequestAddBlockedAccount::user_id() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestAddBlockedAccount.user_id)
  return _internal_user_id();
}
inline void RequestAddBlockedAccount::_internal_set_user_id(int64_t value) {
  
  user_id_ = value;
}
inline void RequestAddBlockedAccount::set_user_id(int64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestAddBlockedAccount.user_id)
}

// int32 duration = 3;
inline void RequestAddBlockedAccount::clear_duration() {
  duration_ = 0;
}
inline int32_t RequestAddBlockedAccount::_internal_duration() const {
  return duration_;
}
inline int32_t RequestAddBlockedAccount::duration() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.RequestAddBlockedAccount.duration)
  return _internal_duration();
}
inline void RequestAddBlockedAccount::_internal_set_duration(int32_t value) {
  
  duration_ = value;
}
inline void RequestAddBlockedAccount::set_duration(int32_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.RequestAddBlockedAccount.duration)
}

// -------------------------------------------------------------------

// ResponseAddBlockedAccount

// int64 seq = 1;
inline void ResponseAddBlockedAccount::clear_seq() {
  seq_ = int64_t{0};
}
inline int64_t ResponseAddBlockedAccount::_internal_seq() const {
  return seq_;
}
inline int64_t ResponseAddBlockedAccount::seq() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseAddBlockedAccount.seq)
  return _internal_seq();
}
inline void ResponseAddBlockedAccount::_internal_set_seq(int64_t value) {
  
  seq_ = value;
}
inline void ResponseAddBlockedAccount::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseAddBlockedAccount.seq)
}

// int32 err_code = 2;
inline void ResponseAddBlockedAccount::clear_err_code() {
  err_code_ = 0;
}
inline int32_t ResponseAddBlockedAccount::_internal_err_code() const {
  return err_code_;
}
inline int32_t ResponseAddBlockedAccount::err_code() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseAddBlockedAccount.err_code)
  return _internal_err_code();
}
inline void ResponseAddBlockedAccount::_internal_set_err_code(int32_t value) {
  
  err_code_ = value;
}
inline void ResponseAddBlockedAccount::set_err_code(int32_t value) {
  _internal_set_err_code(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseAddBlockedAccount.err_code)
}

// string err_string = 3;
inline void ResponseAddBlockedAccount::clear_err_string() {
  err_string_.ClearToEmpty();
}
inline const std::string& ResponseAddBlockedAccount::err_string() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Server.Management.ResponseAddBlockedAccount.err_string)
  return _internal_err_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseAddBlockedAccount::set_err_string(ArgT0&& arg0, ArgT... args) {
 
 err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Server.Management.ResponseAddBlockedAccount.err_string)
}
inline std::string* ResponseAddBlockedAccount::mutable_err_string() {
  std::string* _s = _internal_mutable_err_string();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Server.Management.ResponseAddBlockedAccount.err_string)
  return _s;
}
inline const std::string& ResponseAddBlockedAccount::_internal_err_string() const {
  return err_string_.Get();
}
inline void ResponseAddBlockedAccount::_internal_set_err_string(const std::string& value) {
  
  err_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseAddBlockedAccount::_internal_mutable_err_string() {
  
  return err_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseAddBlockedAccount::release_err_string() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Server.Management.ResponseAddBlockedAccount.err_string)
  return err_string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseAddBlockedAccount::set_allocated_err_string(std::string* err_string) {
  if (err_string != nullptr) {
    
  } else {
    
  }
  err_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), err_string,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (err_string_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    err_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Server.Management.ResponseAddBlockedAccount.err_string)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Management
}  // namespace Server
}  // namespace Protocol
}  // namespace Global

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Management_2eproto
