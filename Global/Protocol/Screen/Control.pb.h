// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Control.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Control_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Control_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Control_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Control_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Control_2eproto;
namespace Global {
namespace Protocol {
namespace Screen {
class ControlKeyPress;
struct ControlKeyPressDefaultTypeInternal;
extern ControlKeyPressDefaultTypeInternal _ControlKeyPress_default_instance_;
class ControlKeyRelease;
struct ControlKeyReleaseDefaultTypeInternal;
extern ControlKeyReleaseDefaultTypeInternal _ControlKeyRelease_default_instance_;
class ControlMouseButtonDoubleClick;
struct ControlMouseButtonDoubleClickDefaultTypeInternal;
extern ControlMouseButtonDoubleClickDefaultTypeInternal _ControlMouseButtonDoubleClick_default_instance_;
class ControlMouseButtonPress;
struct ControlMouseButtonPressDefaultTypeInternal;
extern ControlMouseButtonPressDefaultTypeInternal _ControlMouseButtonPress_default_instance_;
class ControlMouseButtonRelease;
struct ControlMouseButtonReleaseDefaultTypeInternal;
extern ControlMouseButtonReleaseDefaultTypeInternal _ControlMouseButtonRelease_default_instance_;
class ControlMouseMove;
struct ControlMouseMoveDefaultTypeInternal;
extern ControlMouseMoveDefaultTypeInternal _ControlMouseMove_default_instance_;
class ControlMouseWheel;
struct ControlMouseWheelDefaultTypeInternal;
extern ControlMouseWheelDefaultTypeInternal _ControlMouseWheel_default_instance_;
class EnableAutoPublishDesktop;
struct EnableAutoPublishDesktopDefaultTypeInternal;
extern EnableAutoPublishDesktopDefaultTypeInternal _EnableAutoPublishDesktop_default_instance_;
class PublishCursorPosition;
struct PublishCursorPositionDefaultTypeInternal;
extern PublishCursorPositionDefaultTypeInternal _PublishCursorPosition_default_instance_;
class SetClipboardText;
struct SetClipboardTextDefaultTypeInternal;
extern SetClipboardTextDefaultTypeInternal _SetClipboardText_default_instance_;
class Shortcut;
struct ShortcutDefaultTypeInternal;
extern ShortcutDefaultTypeInternal _Shortcut_default_instance_;
}  // namespace Screen
}  // namespace Protocol
}  // namespace Global
PROTOBUF_NAMESPACE_OPEN
template<> ::Global::Protocol::Screen::ControlKeyPress* Arena::CreateMaybeMessage<::Global::Protocol::Screen::ControlKeyPress>(Arena*);
template<> ::Global::Protocol::Screen::ControlKeyRelease* Arena::CreateMaybeMessage<::Global::Protocol::Screen::ControlKeyRelease>(Arena*);
template<> ::Global::Protocol::Screen::ControlMouseButtonDoubleClick* Arena::CreateMaybeMessage<::Global::Protocol::Screen::ControlMouseButtonDoubleClick>(Arena*);
template<> ::Global::Protocol::Screen::ControlMouseButtonPress* Arena::CreateMaybeMessage<::Global::Protocol::Screen::ControlMouseButtonPress>(Arena*);
template<> ::Global::Protocol::Screen::ControlMouseButtonRelease* Arena::CreateMaybeMessage<::Global::Protocol::Screen::ControlMouseButtonRelease>(Arena*);
template<> ::Global::Protocol::Screen::ControlMouseMove* Arena::CreateMaybeMessage<::Global::Protocol::Screen::ControlMouseMove>(Arena*);
template<> ::Global::Protocol::Screen::ControlMouseWheel* Arena::CreateMaybeMessage<::Global::Protocol::Screen::ControlMouseWheel>(Arena*);
template<> ::Global::Protocol::Screen::EnableAutoPublishDesktop* Arena::CreateMaybeMessage<::Global::Protocol::Screen::EnableAutoPublishDesktop>(Arena*);
template<> ::Global::Protocol::Screen::PublishCursorPosition* Arena::CreateMaybeMessage<::Global::Protocol::Screen::PublishCursorPosition>(Arena*);
template<> ::Global::Protocol::Screen::SetClipboardText* Arena::CreateMaybeMessage<::Global::Protocol::Screen::SetClipboardText>(Arena*);
template<> ::Global::Protocol::Screen::Shortcut* Arena::CreateMaybeMessage<::Global::Protocol::Screen::Shortcut>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Global {
namespace Protocol {
namespace Screen {

// ===================================================================

class PublishCursorPosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Screen.PublishCursorPosition) */ {
 public:
  inline PublishCursorPosition() : PublishCursorPosition(nullptr) {}
  ~PublishCursorPosition() override;
  explicit constexpr PublishCursorPosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishCursorPosition(const PublishCursorPosition& from);
  PublishCursorPosition(PublishCursorPosition&& from) noexcept
    : PublishCursorPosition() {
    *this = ::std::move(from);
  }

  inline PublishCursorPosition& operator=(const PublishCursorPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishCursorPosition& operator=(PublishCursorPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishCursorPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishCursorPosition* internal_default_instance() {
    return reinterpret_cast<const PublishCursorPosition*>(
               &_PublishCursorPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PublishCursorPosition& a, PublishCursorPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishCursorPosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishCursorPosition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishCursorPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishCursorPosition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishCursorPosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PublishCursorPosition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishCursorPosition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Screen.PublishCursorPosition";
  }
  protected:
  explicit PublishCursorPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Screen.PublishCursorPosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t x_;
  int32_t y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Control_2eproto;
};
// -------------------------------------------------------------------

class ControlKeyPress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Screen.ControlKeyPress) */ {
 public:
  inline ControlKeyPress() : ControlKeyPress(nullptr) {}
  ~ControlKeyPress() override;
  explicit constexpr ControlKeyPress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlKeyPress(const ControlKeyPress& from);
  ControlKeyPress(ControlKeyPress&& from) noexcept
    : ControlKeyPress() {
    *this = ::std::move(from);
  }

  inline ControlKeyPress& operator=(const ControlKeyPress& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlKeyPress& operator=(ControlKeyPress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlKeyPress& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlKeyPress* internal_default_instance() {
    return reinterpret_cast<const ControlKeyPress*>(
               &_ControlKeyPress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ControlKeyPress& a, ControlKeyPress& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlKeyPress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlKeyPress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlKeyPress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlKeyPress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlKeyPress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControlKeyPress& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlKeyPress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Screen.ControlKeyPress";
  }
  protected:
  explicit ControlKeyPress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // int32 key = 1;
  void clear_key();
  int32_t key() const;
  void set_key(int32_t value);
  private:
  int32_t _internal_key() const;
  void _internal_set_key(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Screen.ControlKeyPress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Control_2eproto;
};
// -------------------------------------------------------------------

class ControlKeyRelease final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Screen.ControlKeyRelease) */ {
 public:
  inline ControlKeyRelease() : ControlKeyRelease(nullptr) {}
  ~ControlKeyRelease() override;
  explicit constexpr ControlKeyRelease(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlKeyRelease(const ControlKeyRelease& from);
  ControlKeyRelease(ControlKeyRelease&& from) noexcept
    : ControlKeyRelease() {
    *this = ::std::move(from);
  }

  inline ControlKeyRelease& operator=(const ControlKeyRelease& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlKeyRelease& operator=(ControlKeyRelease&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlKeyRelease& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlKeyRelease* internal_default_instance() {
    return reinterpret_cast<const ControlKeyRelease*>(
               &_ControlKeyRelease_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ControlKeyRelease& a, ControlKeyRelease& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlKeyRelease* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlKeyRelease* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlKeyRelease* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlKeyRelease>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlKeyRelease& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControlKeyRelease& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlKeyRelease* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Screen.ControlKeyRelease";
  }
  protected:
  explicit ControlKeyRelease(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // int32 key = 1;
  void clear_key();
  int32_t key() const;
  void set_key(int32_t value);
  private:
  int32_t _internal_key() const;
  void _internal_set_key(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Screen.ControlKeyRelease)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Control_2eproto;
};
// -------------------------------------------------------------------

class ControlMouseButtonPress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Screen.ControlMouseButtonPress) */ {
 public:
  inline ControlMouseButtonPress() : ControlMouseButtonPress(nullptr) {}
  ~ControlMouseButtonPress() override;
  explicit constexpr ControlMouseButtonPress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlMouseButtonPress(const ControlMouseButtonPress& from);
  ControlMouseButtonPress(ControlMouseButtonPress&& from) noexcept
    : ControlMouseButtonPress() {
    *this = ::std::move(from);
  }

  inline ControlMouseButtonPress& operator=(const ControlMouseButtonPress& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlMouseButtonPress& operator=(ControlMouseButtonPress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlMouseButtonPress& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlMouseButtonPress* internal_default_instance() {
    return reinterpret_cast<const ControlMouseButtonPress*>(
               &_ControlMouseButtonPress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ControlMouseButtonPress& a, ControlMouseButtonPress& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlMouseButtonPress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlMouseButtonPress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlMouseButtonPress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlMouseButtonPress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlMouseButtonPress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControlMouseButtonPress& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlMouseButtonPress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Screen.ControlMouseButtonPress";
  }
  protected:
  explicit ControlMouseButtonPress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kButtonFieldNumber = 3,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // int32 button = 3;
  void clear_button();
  int32_t button() const;
  void set_button(int32_t value);
  private:
  int32_t _internal_button() const;
  void _internal_set_button(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Screen.ControlMouseButtonPress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t x_;
  int32_t y_;
  int32_t button_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Control_2eproto;
};
// -------------------------------------------------------------------

class ControlMouseButtonRelease final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Screen.ControlMouseButtonRelease) */ {
 public:
  inline ControlMouseButtonRelease() : ControlMouseButtonRelease(nullptr) {}
  ~ControlMouseButtonRelease() override;
  explicit constexpr ControlMouseButtonRelease(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlMouseButtonRelease(const ControlMouseButtonRelease& from);
  ControlMouseButtonRelease(ControlMouseButtonRelease&& from) noexcept
    : ControlMouseButtonRelease() {
    *this = ::std::move(from);
  }

  inline ControlMouseButtonRelease& operator=(const ControlMouseButtonRelease& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlMouseButtonRelease& operator=(ControlMouseButtonRelease&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlMouseButtonRelease& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlMouseButtonRelease* internal_default_instance() {
    return reinterpret_cast<const ControlMouseButtonRelease*>(
               &_ControlMouseButtonRelease_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ControlMouseButtonRelease& a, ControlMouseButtonRelease& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlMouseButtonRelease* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlMouseButtonRelease* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlMouseButtonRelease* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlMouseButtonRelease>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlMouseButtonRelease& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControlMouseButtonRelease& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlMouseButtonRelease* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Screen.ControlMouseButtonRelease";
  }
  protected:
  explicit ControlMouseButtonRelease(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kButtonFieldNumber = 3,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // int32 button = 3;
  void clear_button();
  int32_t button() const;
  void set_button(int32_t value);
  private:
  int32_t _internal_button() const;
  void _internal_set_button(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Screen.ControlMouseButtonRelease)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t x_;
  int32_t y_;
  int32_t button_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Control_2eproto;
};
// -------------------------------------------------------------------

class ControlMouseButtonDoubleClick final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Screen.ControlMouseButtonDoubleClick) */ {
 public:
  inline ControlMouseButtonDoubleClick() : ControlMouseButtonDoubleClick(nullptr) {}
  ~ControlMouseButtonDoubleClick() override;
  explicit constexpr ControlMouseButtonDoubleClick(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlMouseButtonDoubleClick(const ControlMouseButtonDoubleClick& from);
  ControlMouseButtonDoubleClick(ControlMouseButtonDoubleClick&& from) noexcept
    : ControlMouseButtonDoubleClick() {
    *this = ::std::move(from);
  }

  inline ControlMouseButtonDoubleClick& operator=(const ControlMouseButtonDoubleClick& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlMouseButtonDoubleClick& operator=(ControlMouseButtonDoubleClick&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlMouseButtonDoubleClick& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlMouseButtonDoubleClick* internal_default_instance() {
    return reinterpret_cast<const ControlMouseButtonDoubleClick*>(
               &_ControlMouseButtonDoubleClick_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ControlMouseButtonDoubleClick& a, ControlMouseButtonDoubleClick& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlMouseButtonDoubleClick* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlMouseButtonDoubleClick* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlMouseButtonDoubleClick* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlMouseButtonDoubleClick>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlMouseButtonDoubleClick& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControlMouseButtonDoubleClick& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlMouseButtonDoubleClick* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Screen.ControlMouseButtonDoubleClick";
  }
  protected:
  explicit ControlMouseButtonDoubleClick(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kButtonFieldNumber = 3,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // int32 button = 3;
  void clear_button();
  int32_t button() const;
  void set_button(int32_t value);
  private:
  int32_t _internal_button() const;
  void _internal_set_button(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Screen.ControlMouseButtonDoubleClick)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t x_;
  int32_t y_;
  int32_t button_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Control_2eproto;
};
// -------------------------------------------------------------------

class ControlMouseMove final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Screen.ControlMouseMove) */ {
 public:
  inline ControlMouseMove() : ControlMouseMove(nullptr) {}
  ~ControlMouseMove() override;
  explicit constexpr ControlMouseMove(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlMouseMove(const ControlMouseMove& from);
  ControlMouseMove(ControlMouseMove&& from) noexcept
    : ControlMouseMove() {
    *this = ::std::move(from);
  }

  inline ControlMouseMove& operator=(const ControlMouseMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlMouseMove& operator=(ControlMouseMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlMouseMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlMouseMove* internal_default_instance() {
    return reinterpret_cast<const ControlMouseMove*>(
               &_ControlMouseMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ControlMouseMove& a, ControlMouseMove& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlMouseMove* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlMouseMove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlMouseMove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlMouseMove>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlMouseMove& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControlMouseMove& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlMouseMove* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Screen.ControlMouseMove";
  }
  protected:
  explicit ControlMouseMove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Screen.ControlMouseMove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t x_;
  int32_t y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Control_2eproto;
};
// -------------------------------------------------------------------

class ControlMouseWheel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Screen.ControlMouseWheel) */ {
 public:
  inline ControlMouseWheel() : ControlMouseWheel(nullptr) {}
  ~ControlMouseWheel() override;
  explicit constexpr ControlMouseWheel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlMouseWheel(const ControlMouseWheel& from);
  ControlMouseWheel(ControlMouseWheel&& from) noexcept
    : ControlMouseWheel() {
    *this = ::std::move(from);
  }

  inline ControlMouseWheel& operator=(const ControlMouseWheel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlMouseWheel& operator=(ControlMouseWheel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlMouseWheel& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlMouseWheel* internal_default_instance() {
    return reinterpret_cast<const ControlMouseWheel*>(
               &_ControlMouseWheel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ControlMouseWheel& a, ControlMouseWheel& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlMouseWheel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlMouseWheel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlMouseWheel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlMouseWheel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlMouseWheel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControlMouseWheel& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlMouseWheel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Screen.ControlMouseWheel";
  }
  protected:
  explicit ControlMouseWheel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeltaFieldNumber = 1,
  };
  // int32 delta = 1;
  void clear_delta();
  int32_t delta() const;
  void set_delta(int32_t value);
  private:
  int32_t _internal_delta() const;
  void _internal_set_delta(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Screen.ControlMouseWheel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t delta_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Control_2eproto;
};
// -------------------------------------------------------------------

class SetClipboardText final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Screen.SetClipboardText) */ {
 public:
  inline SetClipboardText() : SetClipboardText(nullptr) {}
  ~SetClipboardText() override;
  explicit constexpr SetClipboardText(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetClipboardText(const SetClipboardText& from);
  SetClipboardText(SetClipboardText&& from) noexcept
    : SetClipboardText() {
    *this = ::std::move(from);
  }

  inline SetClipboardText& operator=(const SetClipboardText& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetClipboardText& operator=(SetClipboardText&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetClipboardText& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetClipboardText* internal_default_instance() {
    return reinterpret_cast<const SetClipboardText*>(
               &_SetClipboardText_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SetClipboardText& a, SetClipboardText& b) {
    a.Swap(&b);
  }
  inline void Swap(SetClipboardText* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetClipboardText* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetClipboardText* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetClipboardText>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetClipboardText& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetClipboardText& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetClipboardText* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Screen.SetClipboardText";
  }
  protected:
  explicit SetClipboardText(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Screen.SetClipboardText)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Control_2eproto;
};
// -------------------------------------------------------------------

class EnableAutoPublishDesktop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Screen.EnableAutoPublishDesktop) */ {
 public:
  inline EnableAutoPublishDesktop() : EnableAutoPublishDesktop(nullptr) {}
  ~EnableAutoPublishDesktop() override;
  explicit constexpr EnableAutoPublishDesktop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnableAutoPublishDesktop(const EnableAutoPublishDesktop& from);
  EnableAutoPublishDesktop(EnableAutoPublishDesktop&& from) noexcept
    : EnableAutoPublishDesktop() {
    *this = ::std::move(from);
  }

  inline EnableAutoPublishDesktop& operator=(const EnableAutoPublishDesktop& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnableAutoPublishDesktop& operator=(EnableAutoPublishDesktop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnableAutoPublishDesktop& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnableAutoPublishDesktop* internal_default_instance() {
    return reinterpret_cast<const EnableAutoPublishDesktop*>(
               &_EnableAutoPublishDesktop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EnableAutoPublishDesktop& a, EnableAutoPublishDesktop& b) {
    a.Swap(&b);
  }
  inline void Swap(EnableAutoPublishDesktop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnableAutoPublishDesktop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnableAutoPublishDesktop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnableAutoPublishDesktop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnableAutoPublishDesktop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnableAutoPublishDesktop& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnableAutoPublishDesktop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Screen.EnableAutoPublishDesktop";
  }
  protected:
  explicit EnableAutoPublishDesktop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableFieldNumber = 1,
  };
  // bool enable = 1;
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Screen.EnableAutoPublishDesktop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool enable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Control_2eproto;
};
// -------------------------------------------------------------------

class Shortcut final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Global.Protocol.Screen.Shortcut) */ {
 public:
  inline Shortcut() : Shortcut(nullptr) {}
  ~Shortcut() override;
  explicit constexpr Shortcut(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Shortcut(const Shortcut& from);
  Shortcut(Shortcut&& from) noexcept
    : Shortcut() {
    *this = ::std::move(from);
  }

  inline Shortcut& operator=(const Shortcut& from) {
    CopyFrom(from);
    return *this;
  }
  inline Shortcut& operator=(Shortcut&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Shortcut& default_instance() {
    return *internal_default_instance();
  }
  static inline const Shortcut* internal_default_instance() {
    return reinterpret_cast<const Shortcut*>(
               &_Shortcut_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Shortcut& a, Shortcut& b) {
    a.Swap(&b);
  }
  inline void Swap(Shortcut* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Shortcut* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Shortcut* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Shortcut>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Shortcut& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Shortcut& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Shortcut* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Global.Protocol.Screen.Shortcut";
  }
  protected:
  explicit Shortcut(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // int32 key = 1;
  void clear_key();
  int32_t key() const;
  void set_key(int32_t value);
  private:
  int32_t _internal_key() const;
  void _internal_set_key(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Global.Protocol.Screen.Shortcut)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Control_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PublishCursorPosition

// int32 x = 1;
inline void PublishCursorPosition::clear_x() {
  x_ = 0;
}
inline int32_t PublishCursorPosition::_internal_x() const {
  return x_;
}
inline int32_t PublishCursorPosition::x() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.PublishCursorPosition.x)
  return _internal_x();
}
inline void PublishCursorPosition::_internal_set_x(int32_t value) {
  
  x_ = value;
}
inline void PublishCursorPosition::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.PublishCursorPosition.x)
}

// int32 y = 2;
inline void PublishCursorPosition::clear_y() {
  y_ = 0;
}
inline int32_t PublishCursorPosition::_internal_y() const {
  return y_;
}
inline int32_t PublishCursorPosition::y() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.PublishCursorPosition.y)
  return _internal_y();
}
inline void PublishCursorPosition::_internal_set_y(int32_t value) {
  
  y_ = value;
}
inline void PublishCursorPosition::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.PublishCursorPosition.y)
}

// -------------------------------------------------------------------

// ControlKeyPress

// int32 key = 1;
inline void ControlKeyPress::clear_key() {
  key_ = 0;
}
inline int32_t ControlKeyPress::_internal_key() const {
  return key_;
}
inline int32_t ControlKeyPress::key() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.ControlKeyPress.key)
  return _internal_key();
}
inline void ControlKeyPress::_internal_set_key(int32_t value) {
  
  key_ = value;
}
inline void ControlKeyPress::set_key(int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.ControlKeyPress.key)
}

// -------------------------------------------------------------------

// ControlKeyRelease

// int32 key = 1;
inline void ControlKeyRelease::clear_key() {
  key_ = 0;
}
inline int32_t ControlKeyRelease::_internal_key() const {
  return key_;
}
inline int32_t ControlKeyRelease::key() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.ControlKeyRelease.key)
  return _internal_key();
}
inline void ControlKeyRelease::_internal_set_key(int32_t value) {
  
  key_ = value;
}
inline void ControlKeyRelease::set_key(int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.ControlKeyRelease.key)
}

// -------------------------------------------------------------------

// ControlMouseButtonPress

// int32 x = 1;
inline void ControlMouseButtonPress::clear_x() {
  x_ = 0;
}
inline int32_t ControlMouseButtonPress::_internal_x() const {
  return x_;
}
inline int32_t ControlMouseButtonPress::x() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.ControlMouseButtonPress.x)
  return _internal_x();
}
inline void ControlMouseButtonPress::_internal_set_x(int32_t value) {
  
  x_ = value;
}
inline void ControlMouseButtonPress::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.ControlMouseButtonPress.x)
}

// int32 y = 2;
inline void ControlMouseButtonPress::clear_y() {
  y_ = 0;
}
inline int32_t ControlMouseButtonPress::_internal_y() const {
  return y_;
}
inline int32_t ControlMouseButtonPress::y() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.ControlMouseButtonPress.y)
  return _internal_y();
}
inline void ControlMouseButtonPress::_internal_set_y(int32_t value) {
  
  y_ = value;
}
inline void ControlMouseButtonPress::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.ControlMouseButtonPress.y)
}

// int32 button = 3;
inline void ControlMouseButtonPress::clear_button() {
  button_ = 0;
}
inline int32_t ControlMouseButtonPress::_internal_button() const {
  return button_;
}
inline int32_t ControlMouseButtonPress::button() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.ControlMouseButtonPress.button)
  return _internal_button();
}
inline void ControlMouseButtonPress::_internal_set_button(int32_t value) {
  
  button_ = value;
}
inline void ControlMouseButtonPress::set_button(int32_t value) {
  _internal_set_button(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.ControlMouseButtonPress.button)
}

// -------------------------------------------------------------------

// ControlMouseButtonRelease

// int32 x = 1;
inline void ControlMouseButtonRelease::clear_x() {
  x_ = 0;
}
inline int32_t ControlMouseButtonRelease::_internal_x() const {
  return x_;
}
inline int32_t ControlMouseButtonRelease::x() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.ControlMouseButtonRelease.x)
  return _internal_x();
}
inline void ControlMouseButtonRelease::_internal_set_x(int32_t value) {
  
  x_ = value;
}
inline void ControlMouseButtonRelease::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.ControlMouseButtonRelease.x)
}

// int32 y = 2;
inline void ControlMouseButtonRelease::clear_y() {
  y_ = 0;
}
inline int32_t ControlMouseButtonRelease::_internal_y() const {
  return y_;
}
inline int32_t ControlMouseButtonRelease::y() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.ControlMouseButtonRelease.y)
  return _internal_y();
}
inline void ControlMouseButtonRelease::_internal_set_y(int32_t value) {
  
  y_ = value;
}
inline void ControlMouseButtonRelease::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.ControlMouseButtonRelease.y)
}

// int32 button = 3;
inline void ControlMouseButtonRelease::clear_button() {
  button_ = 0;
}
inline int32_t ControlMouseButtonRelease::_internal_button() const {
  return button_;
}
inline int32_t ControlMouseButtonRelease::button() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.ControlMouseButtonRelease.button)
  return _internal_button();
}
inline void ControlMouseButtonRelease::_internal_set_button(int32_t value) {
  
  button_ = value;
}
inline void ControlMouseButtonRelease::set_button(int32_t value) {
  _internal_set_button(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.ControlMouseButtonRelease.button)
}

// -------------------------------------------------------------------

// ControlMouseButtonDoubleClick

// int32 x = 1;
inline void ControlMouseButtonDoubleClick::clear_x() {
  x_ = 0;
}
inline int32_t ControlMouseButtonDoubleClick::_internal_x() const {
  return x_;
}
inline int32_t ControlMouseButtonDoubleClick::x() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.ControlMouseButtonDoubleClick.x)
  return _internal_x();
}
inline void ControlMouseButtonDoubleClick::_internal_set_x(int32_t value) {
  
  x_ = value;
}
inline void ControlMouseButtonDoubleClick::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.ControlMouseButtonDoubleClick.x)
}

// int32 y = 2;
inline void ControlMouseButtonDoubleClick::clear_y() {
  y_ = 0;
}
inline int32_t ControlMouseButtonDoubleClick::_internal_y() const {
  return y_;
}
inline int32_t ControlMouseButtonDoubleClick::y() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.ControlMouseButtonDoubleClick.y)
  return _internal_y();
}
inline void ControlMouseButtonDoubleClick::_internal_set_y(int32_t value) {
  
  y_ = value;
}
inline void ControlMouseButtonDoubleClick::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.ControlMouseButtonDoubleClick.y)
}

// int32 button = 3;
inline void ControlMouseButtonDoubleClick::clear_button() {
  button_ = 0;
}
inline int32_t ControlMouseButtonDoubleClick::_internal_button() const {
  return button_;
}
inline int32_t ControlMouseButtonDoubleClick::button() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.ControlMouseButtonDoubleClick.button)
  return _internal_button();
}
inline void ControlMouseButtonDoubleClick::_internal_set_button(int32_t value) {
  
  button_ = value;
}
inline void ControlMouseButtonDoubleClick::set_button(int32_t value) {
  _internal_set_button(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.ControlMouseButtonDoubleClick.button)
}

// -------------------------------------------------------------------

// ControlMouseMove

// int32 x = 1;
inline void ControlMouseMove::clear_x() {
  x_ = 0;
}
inline int32_t ControlMouseMove::_internal_x() const {
  return x_;
}
inline int32_t ControlMouseMove::x() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.ControlMouseMove.x)
  return _internal_x();
}
inline void ControlMouseMove::_internal_set_x(int32_t value) {
  
  x_ = value;
}
inline void ControlMouseMove::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.ControlMouseMove.x)
}

// int32 y = 2;
inline void ControlMouseMove::clear_y() {
  y_ = 0;
}
inline int32_t ControlMouseMove::_internal_y() const {
  return y_;
}
inline int32_t ControlMouseMove::y() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.ControlMouseMove.y)
  return _internal_y();
}
inline void ControlMouseMove::_internal_set_y(int32_t value) {
  
  y_ = value;
}
inline void ControlMouseMove::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.ControlMouseMove.y)
}

// -------------------------------------------------------------------

// ControlMouseWheel

// int32 delta = 1;
inline void ControlMouseWheel::clear_delta() {
  delta_ = 0;
}
inline int32_t ControlMouseWheel::_internal_delta() const {
  return delta_;
}
inline int32_t ControlMouseWheel::delta() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.ControlMouseWheel.delta)
  return _internal_delta();
}
inline void ControlMouseWheel::_internal_set_delta(int32_t value) {
  
  delta_ = value;
}
inline void ControlMouseWheel::set_delta(int32_t value) {
  _internal_set_delta(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.ControlMouseWheel.delta)
}

// -------------------------------------------------------------------

// SetClipboardText

// string text = 1;
inline void SetClipboardText::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& SetClipboardText::text() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.SetClipboardText.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetClipboardText::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.SetClipboardText.text)
}
inline std::string* SetClipboardText::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:Global.Protocol.Screen.SetClipboardText.text)
  return _s;
}
inline const std::string& SetClipboardText::_internal_text() const {
  return text_.Get();
}
inline void SetClipboardText::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetClipboardText::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetClipboardText::release_text() {
  // @@protoc_insertion_point(field_release:Global.Protocol.Screen.SetClipboardText.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetClipboardText::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Global.Protocol.Screen.SetClipboardText.text)
}

// -------------------------------------------------------------------

// EnableAutoPublishDesktop

// bool enable = 1;
inline void EnableAutoPublishDesktop::clear_enable() {
  enable_ = false;
}
inline bool EnableAutoPublishDesktop::_internal_enable() const {
  return enable_;
}
inline bool EnableAutoPublishDesktop::enable() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.EnableAutoPublishDesktop.enable)
  return _internal_enable();
}
inline void EnableAutoPublishDesktop::_internal_set_enable(bool value) {
  
  enable_ = value;
}
inline void EnableAutoPublishDesktop::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.EnableAutoPublishDesktop.enable)
}

// -------------------------------------------------------------------

// Shortcut

// int32 key = 1;
inline void Shortcut::clear_key() {
  key_ = 0;
}
inline int32_t Shortcut::_internal_key() const {
  return key_;
}
inline int32_t Shortcut::key() const {
  // @@protoc_insertion_point(field_get:Global.Protocol.Screen.Shortcut.key)
  return _internal_key();
}
inline void Shortcut::_internal_set_key(int32_t value) {
  
  key_ = value;
}
inline void Shortcut::set_key(int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:Global.Protocol.Screen.Shortcut.key)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Screen
}  // namespace Protocol
}  // namespace Global

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Control_2eproto
